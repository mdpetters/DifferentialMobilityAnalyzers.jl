var documenterSearchIndex = {"docs":
[{"location":"types/#Data-Types","page":"Data Types","title":"Data Types","text":"","category":"section"},{"location":"types/","page":"Data Types","title":"Data Types","text":"Three composite data types abstract the DMA setup. The type DMAconfig includes geometry,  flow rate, and polarity.  The type DifferentialMobilityAnalyzer includes the DMA  transmission functions, convolution matrices, and a native DMA mobility grid discretization.  The type SizeDistribution includes a list of vectors to represent aerosol size distributions.  Constructor functions are available to initialize these types.","category":"page"},{"location":"types/#Index","page":"Data Types","title":"Index","text":"","category":"section"},{"location":"types/","page":"Data Types","title":"Data Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"types/#Types","page":"Data Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Data Types","title":"Data Types","text":"DMAconfig","category":"page"},{"location":"types/#DifferentialMobilityAnalyzers.DMAconfig","page":"Data Types","title":"DifferentialMobilityAnalyzers.DMAconfig","text":"DMAconfig\n\nData type to abstract the DMA geometry and state of the fluid. \n\nt::AbstractFloat          # Temperature [K]\np::AbstractFloat          # Pressure [Pa]\nqsa::AbstractFloat        # Sample flow [m3 s-1]\nqsh::AbstractFloat        # Sheath flow [m3 s-1]\nr1::AbstractFloat         # Inner column radius [m]\nr2::AbstractFloat         # Outer column radius [m]\nl::AbstractFloat          # Column length [m]\nleff::AbstractFloat       # Effective length [m]\npolarity::Symbol          # Power supply polarity [:+] or [:-]\nm::Int8                   # Number of charges in charge correction [-]\nDMAtype::Symbol           # Designate :radial, :cylindrical\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 3.33e-6                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,13.0,:-,6,:cylindrical) \n\njulia\n\nnote: Note\nWhen defining a radial DMA, râ‚,râ‚‚,l map to  râ‚,râ‚‚,b as defined in Zhang Shou-Hua Zhang,  Yoshiaki Akutsu, Lynn M. Russell, Richard C. Flagan & John H. Seinfeld (1995)  Radial Differential Mobility Analyzer, Aerosol Science and Technology,  23:3, 357-372, DOI: 10.1080/02786829508965320.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Data Types","title":"Data Types","text":"DifferentialMobilityAnalyzer","category":"page"},{"location":"types/#DifferentialMobilityAnalyzers.DifferentialMobilityAnalyzer","page":"Data Types","title":"DifferentialMobilityAnalyzers.DifferentialMobilityAnalyzer","text":"DifferentialMobilityAnalyzer\n\nThe type DifferentialMobilityAnalyzer contains the DMA transmission functions,  a discretized mobility grid to represent the mobility distribution and precomputed convolution matrices.\n\nÎ©::Function                    # DMA transfer function\nTc::Function                   # Charge filter Function\nTl::Function                   # DMA Penetration efficiency function\nZ::Vector{<:AbstractFloat}     # Mobility array midpoints\nZe::Vector{<:AbstractFloat}    # Mobility array bin edges\nDp::Vector{<:AbstractFloat}    # Mobility diameter midpoints\nDe::Vector{<:AbstractFloat}    # Mobility diameter bin edges\nÎ”lnD::Vector{<:AbstractFloat}  # ln(de[i+1])-ln(de[i])\nğ€::AbstractMatrix              # Convolution matrix\nğ’::AbstractMatrix              # Convolution matrix for initial guess\nğ::AbstractMatrix              # Convolution matrix for no charge filter\nğˆ::AbstractMatrix               # IdentiyMatrix\n\nThe field is initialized using one of the the constructor functions:\n\nsetupDMA\nsetupSMPS\nsetupSMPSdata\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Data Types","title":"Data Types","text":"SizeDistribution","category":"page"},{"location":"types/#DifferentialMobilityAnalyzers.SizeDistribution","page":"Data Types","title":"DifferentialMobilityAnalyzers.SizeDistribution","text":"SizeDistribution\n\nThe type SizeDistribution abstracts the aerosol size distribution. The parameter A is  a set of input parameters, e.g. for a lognormal function. The form contains a symbol  that traces the function or process that created the distribution.\n\nA::Any                        # Input parameters [[N1,Dg1,Ïƒg1], ...] or DMA\nDe::Vector{<:AbstractFloat}   # bin edges\nDp::Vector{<:AbstractFloat}   # bin midpoints\nÎ”lnD::Vector{<:AbstractFloat} # Î”lnD of the grid\nS::Vector{<:AbstractFloat}    # spectral density\nN::Vector{<:AbstractFloat}    # number concentration per bin\nform::Symbol                  # form of the size distribution [:lognormal, ....]\n\nSizeDistributions can be created through one of the constructor functions:\n\nlognormal\ntriangular\nDMALognormalDistribution\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Data Types","title":"Data Types","text":"Regvars","category":"page"},{"location":"types/#DifferentialMobilityAnalyzers.Regvars","page":"Data Types","title":"DifferentialMobilityAnalyzers.Regvars","text":"Regvars\n\nThe type Regvars abstracts the inversion setup, including the convolution matrix, the idenity matrix, the response function (residual vector) and the initial guess. The matrix ğ€'ğ€ is stored as precomputed matrix to avoid recomputing it when evaluating the derivatives in the l-curve search. Setting the number of BLAS threads is experimental.\n\nğ€::Matrix{Float64}     # Convolution matrix\nğˆ::Matrix{Float64}      # Identity matrix\nB::Array{Float64}      # residual vector\nXâ‚€::Array{Float64}     # initial guess\nAA::Matrix{Float64}    # precomputed ğ€'ğ€ for speed\nn::Int                 # Blas threads\n\nRegvars is initialized in the rinv function. See examples folder on how to use this  structure at the top level.\n\n\n\n\n\n","category":"type"},{"location":"types/#Constructor-Functions","page":"Data Types","title":"Constructor Functions","text":"","category":"section"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Functions to compute benchmarks.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"benchmark(bins::Integer, num_threads::Integer)","category":"page"},{"location":"benchmarks/#DifferentialMobilityAnalyzers.benchmark-Tuple{Integer,Integer}","page":"Benchmarks","title":"DifferentialMobilityAnalyzers.benchmark","text":"benchmark(bins::Integer, num_threads::Integer)\n\nComputes benchmarks for the three slowest operations, rinv, setupDMA, setupSMPS\n\nbins is the number of DMA bins\nnum_threads is the number of BLAS threads\n\nThe function returns a dataframe that includes cpuinfo, juliaversion, blasvendor, blasthreads, number of bins, and the three timed benchmarks for rinv, setupDMA, setupSMPS.\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"runbenchmarks()","category":"page"},{"location":"benchmarks/#DifferentialMobilityAnalyzers.runbenchmarks-Tuple{}","page":"Benchmarks","title":"DifferentialMobilityAnalyzers.runbenchmarks","text":"runbenchmarks()\n\nRuns a set of standard benchmarks, varying the number bins and returns a dataframe with results. This function may take several minutes to complete. \n\n\n\n\n\n","category":"method"},{"location":"physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"The following functions are used to define the physics of the instrument. ","category":"page"},{"location":"physics/#Index","page":"Physics","title":"Index","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Pages = [\"physics.md\"]","category":"page"},{"location":"physics/#Functions","page":"Physics","title":"Functions","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Î·(Î›::DMAconfig)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.Î·-Tuple{DMAconfig}","page":"Physics","title":"DifferentialMobilityAnalyzers.Î·","text":"Î·(Î›::DMAconfig)\n\nÎ· is the viscosity of air in [Pa s] and depends on temperature [K]. Temperature  is taken from the DMA configuration. Currently only dry air is supported.\n\neta = 183245times10^-5 exp left(15 ln leftfracT2961rightright)left  (frac40655T+1104 right) \n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 3.33e-6                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nviscosity = Î·(Î›)\n\n\n\n\n\n","category":"method"},{"location":"physics/","page":"Physics","title":"Physics","text":"cc(Î›::DMAconfig, d)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.cc-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.cc","text":"cc(Î›::DMAconfig, d)\n\nCunningham slip-flow correction factor. The slip flow correction accounts for the  decreased drag particles experience relative to Stokes' drag force when particle  size approaches the scale of the mean free path of air. It is computed following  Hinds (1999) Eq. 3.20. Temperature and pressure are taken from the DMA configuration. The units of diameter are in [m] and the function accepts scalars or arrays.\n\nc_c = 1+fraclambdad_p left(234+105 exp left-039 fracd_plambdarightright)\n\nwhere d_p is the particle diameter and lambda is the mean  free path of air, which is computed as a function of pressure and temperature. \n\nExample Usage\n\nDp = exp10.(range(log10(1e-9), stop=log10(1000e-9), length=100))\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 3.33e-6                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \ncorrection = cc(Î›, Dp)\n\n\n\n\n\n","category":"method"},{"location":"physics/","page":"Physics","title":"Physics","text":"dab(Î›::DMAconfig, d)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.dab-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.dab","text":"dab(Î›::DMAconfig, d)\n\nThe diffusion coefficient of particles in air, d_ab, describes the random  displacement of particles due to Brownian motion. It is computed via the Stokes-Einstein  relation (Hinds, 1999, Eq. 7.20). Temperature and pressure are taken from the DMA  configuration. The units of diameter are in [m] and the function accepts scalars or arrays.\n\nd_ab = frack_bTc_c3pieta d_p\n\nwhere k_b is Boltzmann's constant and eta is the viscosity of air in [Pa s],  c_c is the Cunningham slip flow correction and d_p is the particle diameter. d_ab is in [mÂ² sâ»Â¹].\n\nExample Usage\n\nDp = exp10.(range(log10(1e-9), stop=log10(1000e-9), length=100))\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 3.33e-6                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \ndiffusion_coefficient = dab(Î›,Dp)\n\n\n\n\n\n","category":"method"},{"location":"physics/","page":"Physics","title":"Physics","text":"dtoz(Î›::DMAconfig, d)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.dtoz-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.dtoz","text":"dtoz(Î›::DMAconfig, d)\n\nThe function returns the mobility z according to  \n\nd_p =  frackec_c3pi eta z^s\n\nwhere e is the elementary charge,  k is the number of charges on the particle,  c_c is the Cunningham correction factor, and eta is the viscosity of the fluid.  The diameter in dtoz is in units of [m].\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 3.33e-6                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nmobility = dtoz(Î›,dp*1e-9) # [m2 V-1 s-1]\n\n\n\n\n\n","category":"method"},{"location":"physics/","page":"Physics","title":"Physics","text":"vtoz(Î›::DMAconfig, v)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.vtoz-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.vtoz","text":"vtoz(Î›::DMAconfig, v)\n\nConverts between voltage and selected mobility. \n\nFor the cylindrical DMA and balanced flows: \n\nz^s = fracq_sh2pi l v ln left(fracr_2r_1right)\n\nFor the radial DMA and balanced flows:\n\nz^s = fracq_sh lpi v left(r_2^2 - r_1^2right)\n\nwhere vis the potential applied between the inner and out section of the annulus,r_1,r_2, andlare the dimensions of the cylindrical DMA  andq_{sh}` is  the sheath flow rate.\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 3.33e-6                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nmobility = vtoz(Î›,1000.0) # [m2 V-1 s-1]\n\n\n\n\n\n","category":"method"},{"location":"physics/","page":"Physics","title":"Physics","text":"Î©(Î›::DMAconfig, Z, zs)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.Î©-Tuple{DMAconfig,Any,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.Î©","text":"Î©(Î›::DMAconfig, Z, zs)\n\nThe DMA transfer function is the probability that a particle of a particle of a given size  exits the classifier via the sample flow. The diffusive broadened DMA transfer function is  computed assuming blanced sheath and excess flows using the expression of Stolzenburg  and McMurry (2008).\n\nOmega(tildezbetasigma) = fracsigmasqrt2betaleftepsilon left(      fractildez-(1+beta)sqrt2sigma right) + epsilon left (fractildez-     (1-beta)sqrt2sigma right) - 2epsilon left      ( fractildez-1sqrt2sigmaright)  right\n\nwhere tildez = fraczz^s is the dimensionless mobility, zis the particle  mobilityz^sis the centroid mobility selected by the DMA,\\epsilon = x \\mathrm{erf}(x) +\\left(\\exp(-x^2)/\\sqrt{\\pi}\\right),\\mathrm{erf}is  the error function, and\\beta = \\frac{q_{sa}}{q_{sh}}. The parameter\\sigmaaccounts for diffusional broading of the transfer function. Assuming plug flow,\\sigma` can be computed using the following equations Hagwood (1999) \n\ngamma = left(fracr_1r_2right)^2\n\nI = frac12(1+Î³)\n\nkappa = fraclr_2r_2^2-r_1^2\n\nG = frac4(1+beta)^2(1-Î³) leftI+2(1+beta)kappa^-2 right \n\nsigma = sqrtfrac2Gpi ld_abq_sh\n\nInputs for flow are taken from the DMAconfig. The function expects a mobility scalar z or vector Z, and a centroid mobility zË¢.\n\nExample Usage\n\nzË¢ = dtoz(Î›, 200e-9)      # centroid mobility for Dp = 200 nm\nz = [1e-9, 1e-8, 1e-7]    # mobility \nÎ©(Î›,z,zË¢)                 # Output of the transfer function\n\nnote: Note\nThe function Î© is embedded in the the Type DifferentialMobilityAnalyzers.jl, which  assigns Î´.Î© either to this function Î© or Î©av applicable to scanning mode,\n\n\n\n\n\n","category":"method"},{"location":"physics/","page":"Physics","title":"Physics","text":"Î©av(Î›::DMAconfig, i::Int, k::Int; nint = 20)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.Î©av-Tuple{DMAconfig,Int64,Int64}","page":"Physics","title":"DifferentialMobilityAnalyzers.Î©av","text":"Î©av(Î›::DMAconfig, i::Int, k::Int; nint = 20)\n\nTransfer function of the scanning DMA. The voltage continuously changes. Signal is acquired during some discrete time interval t_c. The SMPS transfer function is calculated as the average DMA transfer function during the time interval tt+t_c (Wang and Flagan, 1990). \n\nOmega_av = frac1tcint_t_i^t_i+t_c Omega(Zz^s(t)) dt\n\nwhere t_i is the start time when counting begins in channel i, z^s(t) is the  selected centroid mobility at time t and is calculated from the applied voltage. \n\nnote: Note\nThe function Î© is embedded in the the Type DifferentialMobilityAnalyzers.jl, which  assigns Î´.Î© either to this function Î©av or Î© applicable to stepping mode.This function is used internally to compute the SMPS function and is tied to  a specific DMA setup and scanning profile. It is called by the setupSMPS constructor functions. See setupSMPS in the source code to see how it is used.\n\n\n\n\n\n","category":"method"},{"location":"physics/","page":"Physics","title":"Physics","text":"getTc(Î›::DMAconfig)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.getTc-Tuple{DMAconfig}","page":"Physics","title":"DifferentialMobilityAnalyzers.getTc","text":"getTc(Î›::DMAconfig)\n\nReturns a function \n\nTc(k::Integer, Dp)\n\nto compute the charging efficiency. Tc depends of the polarity set in DMAconfig.\n\nCharging efficiency (charge equilibrium) obtained in the bipolar charger is computed based  on the parameterized measurements by Wiedensohler et al. (1988) with coefficients taken  from the TSI 3080 Manual (2009). \n\nT_c(k) = 10^left sum_i=1^6 a_i (k) left ln left(fracD_pnmright) right^i-1 right\n\nwhere k = -2-112 is the number and polarity of particle charge and a_i are  empirical coefficients. \n\nFor k ge pm 3, the formula from the TSI manual is used:\n\nT_c(k) = fracesqrt4pi^2epsilon D_pk_bT exp left( frac-fracleftk -  2piepsilon D_pk_bT ln(0875)right^2e^2 frac4piepsilon D_pk_bTe^2 right)\n\nwhere e is the elementary charge and epsilon is the dielectric constant for air.\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 3.33e-6                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nTc = getTc(Î›)\nTc(1,100.0) # Note that Dp is in units of nm!\n\nnote: Note\nThe function Tc is computed during DMA grid initialization and embedded in the  DifferentialMobilityAnalyzer data type. It is usually accessed through this grid. The diameter Dp is in units of nm.\n\n\n\n\n\n","category":"method"},{"location":"physics/","page":"Physics","title":"Physics","text":"Tl(Î›::DMAconfig, Dp)","category":"page"},{"location":"physics/#DifferentialMobilityAnalyzers.Tl-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.Tl","text":"Tl(Î›::DMAconfig, Dp)\n\nPenetration efficiency through the TSI cylindrical DMA using the parameterization by  Reineking & PorstendÃ¶rfer (1986). The particle diameter Dp is in [nm].\n\nT_l = 082exp(-115u)+01exp(-700u)+003exp(-1800u)+002exp(-3400u)\n\nwhere u = fracd_ab l_effq_sa l_eff is the parameterized effective  diffusion length, and q_sa is the aerosol flow rate through the DMA. \n\nnote: Note\nÎ› contains the effective length, aerosol flow rate, temperature and pressure to  compute d_ab. To treat multiple DMAs with different {leff, qsa,  t, p} in a single script, the function Tl is  embedded  in the  DifferentialMobilityAnalyzer data type.\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"DifferentialMobilityAnalyzers.jl","title":"DifferentialMobilityAnalyzers.jl","text":"Author = \"Markus D. Petters\"","category":"page"},{"location":"library/#DifferentialMobilityAnalyzers.jl","page":"DifferentialMobilityAnalyzers.jl","title":"DifferentialMobilityAnalyzers.jl","text":"","category":"section"},{"location":"library/","page":"DifferentialMobilityAnalyzers.jl","title":"DifferentialMobilityAnalyzers.jl","text":"<!â€“ ```@index Modules = [DifferentialMobilityAnalyzers]","category":"page"},{"location":"library/","page":"DifferentialMobilityAnalyzers.jl","title":"DifferentialMobilityAnalyzers.jl","text":"\n<!-- ```@autodocs\nModules = [DifferentialMobilityAnalyzers]","category":"page"},{"location":"library/","page":"DifferentialMobilityAnalyzers.jl","title":"DifferentialMobilityAnalyzers.jl","text":"â€“>","category":"page"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators are used to transform size distributions. The operators overload the Base or  LinearAlgebra methods. Operators fall into two broad categories: operators changing  number concentration and spectral density fields (ğ•Ÿ.N and ğ•Ÿ.S) and operators that change  the sizing vector (ğ•Ÿ.Dp). The former include ğ•Ÿâ‚ + ğ•Ÿâ‚‚, ğ•Ÿâ‚ - ğ•Ÿâ‚‚, ğ•Ÿâ‚ âˆ— ğ•Ÿâ‚‚, ğ•Ÿâ‚ / ğ•Ÿâ‚‚, a âˆ— ğ•Ÿ,  T .âˆ— ğ•Ÿ, and A âˆ— ğ•Ÿ, while the latter include a Â· ğ•Ÿ and T Â· ğ•Ÿ.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operator Description\nğ•Ÿâ‚ + ğ•Ÿâ‚‚ Superposition of the distributions ğ•Ÿâ‚ and ğ•Ÿâ‚‚\nğ•Ÿâ‚ - ğ•Ÿâ‚‚ Superposition of the distributions ğ•Ÿâ‚ and ğ•Ÿâ‚‚\na âˆ— ğ•Ÿ Uniform scaling of the concentration fields by factor a\nğ€ âˆ— ğ•Ÿ Matrix multiplication of ğ€ and concentration\nğ•Ÿâ‚ * ğ•Ÿâ‚‚ Scaled such that total number concentration equals to N1 âˆ— N2\nğ•Ÿâ‚ / ğ•Ÿâ‚‚ Ratio of concentration fields of distributions ğ•Ÿâ‚.N and ğ•Ÿâ‚‚.N\na Â· ğ•Ÿ Uniform scaling of the diameter field of the size distribution by factor a\nT Â· ğ•Ÿ Elementwise scaling the diameter field by factor T\n ","category":"page"},{"location":"operators/#Index","page":"Operators","title":"Index","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Pages = [\"operators.md\"]","category":"page"},{"location":"operators/#Number-Operators","page":"Operators","title":"Number Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"+(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)","category":"page"},{"location":"operators/#Base.:+-Tuple{SizeDistribution,SizeDistribution}","page":"Operators","title":"Base.:+","text":"+(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)\n\nDefines the sum of two size distributions. If diameter grids are not equal, then the diameter grid of n2 is interpolated onto the n1 grid prior to addition.\n\nğ•© = ğ•Ÿâ‚ + ğ•Ÿâ‚‚ \n\nis defined such that \n\nğ•©.S = ğ•Ÿâ‚.S + ğ•Ÿâ‚‚.S \nğ•©.N = ğ•©.S .* ğ•Ÿ.Î”lnD \n\nExample Usage\n\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 64)\nğ•© = ğ•Ÿâ‚ + ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"operators/","page":"Operators","title":"Operators","text":"-(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)","category":"page"},{"location":"operators/#Base.:--Tuple{SizeDistribution,SizeDistribution}","page":"Operators","title":"Base.:-","text":"-(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)\n\nDefines the sum of two size distributions. If diameter grids are not equal, then the diameter grid of n2 is interpolated onto the n1 grid prior to addition.\n\nğ•© = ğ•Ÿâ‚ - ğ•Ÿâ‚‚ \n\nis defined such that \n\nğ•©.S = ğ•Ÿâ‚.S - ğ•Ÿâ‚‚.S \nğ•©.N = ğ•©.S .* ğ•Ÿ.Î”lnD \n\nExample Usage\n\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 64)\nğ•© = ğ•Ÿâ‚ - ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"operators/","page":"Operators","title":"Operators","text":"*(a::Number, ğ•Ÿ::SizeDistribution)","category":"page"},{"location":"operators/#Base.:*-Tuple{Number,SizeDistribution}","page":"Operators","title":"Base.:*","text":"*(a::Number, ğ•Ÿ::SizeDistribution)\n\nMultiplication of scalar and size distribution. The net result is a scaling of the  number concentration of the spectra by a. The function is symmetric such that a * ğ•Ÿ == ğ•Ÿ * a.\n\nLet a denote a number and ğ•Ÿ denote a size distribution. Then\n\nğ•© = a * ğ•Ÿ \n\nis defined such that\n\nğ•©.N = a * ğ•Ÿ.N\nğ•©.S = a * ğ•Ÿ.S\n\nExample Usage\n\nğ•Ÿ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•© = 2.3 * ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"operators/","page":"Operators","title":"Operators","text":"*(ğ€::AbstractMatrix, ğ•Ÿ::SizeDistribution)","category":"page"},{"location":"operators/#Base.:*-Tuple{AbstractArray{T,2} where T,SizeDistribution}","page":"Operators","title":"Base.:*","text":"*(ğ€::AbstractMatrix, ğ•Ÿ::SizeDistribution)\n\nMultiplication of matrix and size distribution. The net result is the multiplication of the  matrix with number concentration and spectral density fields. \n\nLet ğ€ denote an nxn matrix where n equals the number of size bins of ğ•Ÿ. Then\n\nğ•© = ğ€ * ğ•Ÿ \n\nis defined such that \n\nğ•©.N = ğ€ * ğ•Ÿ.N\nğ•©.S = ğ€ * ğ•Ÿ.S\n\nğ•Ÿ = lognormal([[100, 100, 1.1]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ€ = rand(256,256)\nğ•© = ğ€ * ğ•Ÿ                                        \n\n\n\n\n\n","category":"method"},{"location":"operators/","page":"Operators","title":"Operators","text":"*(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)","category":"page"},{"location":"operators/#Base.:*-Tuple{SizeDistribution,SizeDistribution}","page":"Operators","title":"Base.:*","text":"*(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)\n\nMultiplication of size distribution and a size distribution. The net result is a  size distribution that has total number concentration square. For a probability  distributions that by definition integrate to unity, this operation corresponds to  the product of two random variates with distribution 1 and 2.\n\nLet ğ•Ÿâ‚ and ğ•Ÿâ‚‚ denote a two size distribution defined on the same diameter grid. Then\n\nğ•© = ğ•Ÿâ‚ * ğ•Ÿâ‚‚ \n\nis defined such that \n\nNsq = ğ•Ÿâ‚.N * ğ•Ÿâ‚‚.N\nğ•©.N = sum(ğ•Ÿâ‚.N) * sum(ğ•Ÿâ‚‚.N) * Nsq./sum(Nsq)\nğ•©.S = N ./ ğ•Ÿâ‚.Î”dlnD\n\nExample Usage\n\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 64)\nğ•© = ğ•Ÿâ‚ * ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"operators/","page":"Operators","title":"Operators","text":"/(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)","category":"page"},{"location":"operators/#Base.:/-Tuple{SizeDistribution,SizeDistribution}","page":"Operators","title":"Base.:/","text":"/(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)\n\nDivision of size distribution and size distribution. The net result is a size distribution  that is the ratio of the concentration vectors.\n\nLet ğ•Ÿâ‚ and ğ•Ÿâ‚‚ denote a two size distribution defined on the same diameter grid. Then\n\nğ•© = ğ•Ÿâ‚ / ğ•Ÿâ‚‚\n\nis defined such that\n\nN = ğ•Ÿâ‚.N ./ ğ•Ÿâ‚‚.N\nS = ğ•Ÿâ‚.S ./ ğ•Ÿâ‚‚.S\n\nExample Usage\n\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 64)\nğ•© = ğ•Ÿâ‚ / ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"operators/#Size-Operators","page":"Operators","title":"Size Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"LinearAlgebra.:â‹…(a::Number, ğ•Ÿ::SizeDistribution)","category":"page"},{"location":"operators/#LinearAlgebra.:â‹…-Tuple{Number,SizeDistribution}","page":"Operators","title":"LinearAlgebra.:â‹…","text":"â‹…(a::Number, ğ•Ÿ::SizeDistribution)\n\nMultiplication of a scalar and a size distribution. The net result is a uniform diameter  shift of the size distribution. The function is symmetric such that a â‹… ğ•Ÿ == ğ•Ÿ â‹… a.\n\nLet a denote a floating point scalar and ğ•Ÿ denote a size distribution. Then\n\nğ•© = a â‹… ğ•Ÿ\n\nis defined such that \n\nğ•©.Dp = a * ğ•Ÿ.Dp \n\nExample Usage\n\na = 2.0 \nğ•Ÿ = lognormal([[300, 100, 1.3]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•© = a â‹… ğ•Ÿ \n\n\n\n\n\n","category":"method"},{"location":"operators/","page":"Operators","title":"Operators","text":"LinearAlgebra.:â‹…(A::Vector{<:AbstractFloat}, ğ•Ÿ::SizeDistribution)","category":"page"},{"location":"operators/#LinearAlgebra.:â‹…-Tuple{Array{var\"#s3\",1} where var\"#s3\"<:AbstractFloat,SizeDistribution}","page":"Operators","title":"LinearAlgebra.:â‹…","text":"LinearAlgebra.:â‹…(A::Vector{<:AbstractFloat}, ğ•Ÿ::SizeDistribution)\n\nDot product of vector and size distribution.   The net result is diameter dependent shift of  the size distribution. The function is symmetric such that A â‹… ğ•Ÿ == ğ•Ÿ â‹… A.\n\nLet T denote a floating point vector with the same number of elements as the size distribution ğ•Ÿ. Then\n\nğ•© = T â‹… ğ•Ÿ \n\nis defined such that \n\nğ•©.Dp = T .* ğ•Ÿ.dp \n\nExample Usage\n\nğ•Ÿ = lognormal([[100, 100, 1.1]]; d1 = 10.0, d2 = 1000.0, bins = 256)  \nÎ¼,Ïƒ = 80.0, 2000.0\nT = (1.0 .+ erf.((ğ•Ÿ.Dp .- Î¼)./(sqrt(2Ïƒ)))) \nğ•© = T â‹… ğ•Ÿ  \n\n\n\n\n\n","category":"method"},{"location":"notebooks/#Notebooks","page":"Notebooks","title":"Notebooks","text":"","category":"section"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"The project is documented in a journal manuscript. The original submission included 12 Supplementary Jupyter Notebooks. The links open the notebooks in viewer mode via  NBViewer. The notebooks have been edited for compatibility and readability.  A virtual machine with working copies of the originally submitted notebooks are archived on zenodo. Instructions for setting up the  machine are in the supporting information of the manuscript.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Manuscript (Open Access) ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S1. Differential Mobility Analyzer ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook introduces the Differential Mobility Analyzer (DMA) and demonstrates basic  functions. The notebook includes Figures of the schematic of the DMA, the size dependence  of the Cunningham slip flow correction factor, particle diffusion coefficient, penetration  efficiency through the DMA, and the fractional charging efficiency of the bipolar charger.  It also includes examples of the normalized DMA transfer functions.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S2. Fredholm Integral Equation ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook introduces the Fredholm integral equation and derives the discretized  solution via the forward convolution matrix. The notebook demonstrates how the convolution matrix is computed for any set of transmission functions.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S3. Size Distribution Arithmetic ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook introduces the SizeDistribution type. Seven unique operations are defined and showcased: (a) Multiplication of scalar and size distribution, (b) Multiplication of vector and size distribution, (c) Multiplication of matrix and size distribution, (d) Multiplication of size distribution and size distribution, (e) Division of size distribution and size distribution (f) Dot product of scalar and size distribution, (g) Dot product of vector and size distribution, and (h) Addition of two size distributions.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S4. Single Mobility Classification ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates how the software can be used to find the true size distribution of monodisperse mobility selected particles. It also demonstrates how to compute the selected number, surface area, and volume concentration.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S5. Size Distribution Inversion Using Regularization ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates how to invert a size distribution from a measured noisy response function. Application of the convolution matrix together with a Twomey inverse and the L-curve algorithm are used to invert a synthetic dataset.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S6. Size Distribution Inversion of Ambient Data ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook applies the regularized inverse to a published dataset. Results are compared to the inversion output of the manufacturer supplied software and evaluates the degree of agreement between this package and the manufacturer software.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S7. Size resolved CCN measurements ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates calculations related to the the configuration where a single differential mobility analyzer is used together with a condensation particle counter and cloud condensation nuclei counter. It is demonstrated how to express the response function in terms of the language and how to fit the response function to infer the cloud droplet activation diameter.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S8. Hygroscopicity Tandem DMA ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates calculations related to the configuration where the first differential mobility is used as classifier. The output is conditioned in a humidifier and the resulting size distribution is measured using a second DMA in scanning mode together with a condensation particle counter (or other instrument) as detector. It is demonstrated how the language can be used to express the response function of the second differential mobility analyzer used either with or without bipolar charger.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S9. Volatility Tandem DMA ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates calculations related to the configuration where the first differential mobility is used as classifier. The output is conditioned in an evaporator or condenser and the resulting size distribution is measured using a second differential mobility analyzer in scanning mode together with a condensation particle counter (or other instrument) as detector. It is demonstrated how the language can be used to express the response function of the second differential mobility analyzer used either with or without bipolar charger.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S10. Dimer Coagulation and Isolation ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates calculations related to the configuration where two DMAs are used to size select particles of opposite charge. The two populations are merged and allowed to coagulate. Coagulated dimers are isolated using an electrostatic filter. The dimers are charge neutralized and the size distribution is measured using a DMA operated in stepping or scanning mode. It is demonstrated how the language can be used to express the response function of the third differential mobility analyzer.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S11. PartMC Simulations","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook presents an overview over coagulation theory. It is shown how to predict the coagulated distribution using Size Distribution Arithmetic (Notebook S3). The approach is compared to model predictions with the Particle-resolved Monte Carlo code for atmospheric aerosol simulation (PartMC)","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S12. FORTRAN API ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates how to construct a convolution matrix using a DMA transfer function defined in a FORTRAN routine. The notebook explains how to compile the routine to a shared library and setup ccall to pass variables to and from the FORTRAN routine.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Link to Virtual Machine","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Julia is just-in-time (JIT) compiled, which means that the first time you run a block of code it will be slow. Users new to Julia are strongly encouraged to start with the Docker version provided with the Tutorial. The version bundled in the Docker container comes with an optimized system image, which has a much reduced JIT lag. It also simplifies the installation. The version in the Docker container/tutorial can also be used to work with the package. ","category":"page"},{"location":"quickstart/#Local-Installation","page":"Quick Start","title":"Local Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The package can be installed from the Julia package prompt with","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia> ]add  https://github.com/mdpetters/DifferentialMobilityAnalyzers.jl.git","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The closing square bracket switches to the package manager interface and the add command installs the package and any missing dependencies. To return to the Julia REPL hit the delete key.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"To load the package run","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia> using DifferentialMobilityAnalyzers","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Additional dependencies are needed when running the notebooks on the local install. ","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia> ] add Calculus DataFrames Distributions Glob IJulia Interpolations LambertW LinearAlgebra LsqFit NetCDF ORCA PlotlyJS Plots Printf ProgressMeter Random SpecialFunctions StatsBase Gadfly Compose","category":"page"},{"location":"#DifferentialMobilityAnalyzers.jl","page":"Home","title":"DifferentialMobilityAnalyzers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for working with data from differential mobility analyzers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DifferentialMobilityAnalyzers.jl bundles a set of abstractions to write concise forward and inverse models of experimental setups that involve  differential mobility analyzers. Abstractions include specialized data types, operators, functions, and conventions. Conventions include rules for typesetting fonts and sub- and superscripting variables. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure. Schematic of a differential mobility analyzer. The cylindrical differential mobility analyzer is an annular capacitor. The column's properties are defined by the radii r_1, r_2, the length of the aerosol path, l. Operation conditions are defined by the the electric potential v applied across the annulus and the four flow rates: sheath flow, q_sh, polydisperse aerosol flow q_a, excess flow, q_ex, and monodisperse sample flow, q_sa. Throughout this work it is assumed that the flows are balanced, i.e. q_sh = q_ex and q_sa = q_a. The two flows tracked are q_sh and q_{sa}``. ","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Primitives to simplify working with size distribution data\nImplementation of physical equations describing DMAs\nComputational solution of the discretized Fredholm integral equation\nGeneration of custom convolution matrices \nFast size distribution inversion using Tikhonov regularization\nModeling of particle transmission through single and chained DMA setups","category":"page"},{"location":"helpers/#Helper-Functions","page":"Helper Functions","title":"Helper Functions","text":"","category":"section"},{"location":"helpers/","page":"Helper Functions","title":"Helper Functions","text":"The following functions help in various task.","category":"page"},{"location":"helpers/#Index","page":"Helper Functions","title":"Index","text":"","category":"section"},{"location":"helpers/","page":"Helper Functions","title":"Helper Functions","text":"Pages = [\"helpers.md\"]","category":"page"},{"location":"helpers/#Functions","page":"Helper Functions","title":"Functions","text":"","category":"section"},{"location":"helpers/","page":"Helper Functions","title":"Helper Functions","text":"Î£(f, i)","category":"page"},{"location":"helpers/#DifferentialMobilityAnalyzers.Î£-Tuple{Any,Any}","page":"Helper Functions","title":"DifferentialMobilityAnalyzers.Î£","text":"Î£(f, i)\n\nDefined as shorthand:\n\nÎ£(f, i) = mapreduce(f, +, 1:i)\n\nThe function evaluates f(X) for X = [1,...,i] and sums the result. If f(X) evaluates to a vector or SizeDistribution, the sum is the sum of the vectors or  SizeDistributions.\n\nExample Usage\n\nTc = getTc(Î›)\nÎ£(k -> Tc(k,100.0),2)  # evaluate the sum of Tc(1, 100.0), Tc(2, 100.0)\n\n\n\n\n\n","category":"method"},{"location":"helpers/","page":"Helper Functions","title":"Helper Functions","text":"clean(x)","category":"page"},{"location":"helpers/#DifferentialMobilityAnalyzers.clean-Tuple{Any}","page":"Helper Functions","title":"DifferentialMobilityAnalyzers.clean","text":"clean(x)\n\nDefined as shorthand:\n\nclean(x) = map(x -> x < 0.0 ? 0.0 : x, x)\n\nThe function removes negative numbers and set them zero. It is used to cleanup  inverted size distribution data, which may contain small negative values from inversion noise. \n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
