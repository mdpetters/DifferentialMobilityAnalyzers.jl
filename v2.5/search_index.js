var documenterSearchIndex = {"docs":
[{"location":"lib/forward/#Forward-Models","page":"Forward Models","title":"Forward Models","text":"","category":"section"},{"location":"lib/forward/","page":"Forward Models","title":"Forward Models","text":"These routines are used for forward models.","category":"page"},{"location":"lib/forward/#Index","page":"Forward Models","title":"Index","text":"","category":"section"},{"location":"lib/forward/","page":"Forward Models","title":"Forward Models","text":"Pages = [\"lib/forward.md\"]","category":"page"},{"location":"lib/forward/#Functions","page":"Forward Models","title":"Functions","text":"","category":"section"},{"location":"lib/forward/#TDMA1Dpdf","page":"Forward Models","title":"TDMA1Dpdf","text":"","category":"section"},{"location":"lib/forward/","page":"Forward Models","title":"Forward Models","text":"TDMA1Dpdf","category":"page"},{"location":"lib/forward/#DifferentialMobilityAnalyzers.TDMA1Dpdf","page":"Forward Models","title":"DifferentialMobilityAnalyzers.TDMA1Dpdf","text":"TDMA1Dpdf(ğ•Ÿáµ¢â‚™,  Î›â‚áµ¢â‚™ , Î›â‚‚áµ¢â‚™, dma2rangeáµ¢â‚™)\n\nReturns a function model that models the output of a tandem DMA for an  input pdf of growth factors. Tne function is specialized for a specific size distribution\n\nğ•Ÿáµ¢â‚™ is the size distribution with  Dp sorted in in ascending order and units of nm\nÎ›â‚áµ¢â‚™ , Î›â‚‚áµ¢â‚™ DMA 1 and 2 configuration of type of DMAconfig\ndma2rangeáµ¢â‚™ a tuple (Dd, gmin, gmax, n) where   Dd is the dry diameter selected by DMA 1 in units of m   gmin is the lower range of growth factors scanned by DMA2   gmax is the upper range of growth factor scanned by DMA2   n is the number of bins to represent the DMA2 grid\n\nExample use\n\nusing Distributions\nusing DifferentialMobilityAnalyzers\nusing Gadfly\n\nt, p = 295.15, 1e5\nqsa, qsh = 1.66e-5, 8.33e-5\nrâ‚, râ‚‚, l = 9.37e-3, 1.961e-2, 0.44369\nÎ›â‚ = DMAconfig(t, p, qsa, qsh, râ‚, râ‚‚, l, 0.0, :-, 6, :cylindrical)\nÎ›â‚‚ = DMAconfig(t, p, qsa, qsh, râ‚, râ‚‚, l, 0.0, :-, 6, :cylindrical)\nbins, zâ‚, zâ‚‚ = 120, dtoz(Î›â‚, 500e-9), dtoz(Î›â‚, 30e-9) # bins, upper, lower mobility limit\nÎ´â‚ = setupDMA(Î›â‚, zâ‚, zâ‚‚, bins)                \nAx = [[1300.0, 60.0, 1.4], [5000.0, 220.0, 1.6]] \nğ•Ÿ = DMALognormalDistribution(Ax, Î´â‚)\n\n# scan 100 nm Dd from 0.8Dd to 3.0Dd with 100 bins\ndma2range = (100e-9, 0.8, 3.0, 30)\n\n# Get the model function\nmodel = TDMA1Dpdf(ğ•Ÿ, Î›â‚, Î›â‚‚, dma2range)\n\n# Growth factor grid along with the PDF is evaluated over\nAx = [[1300.0, 60.0, 1.4], [5000.0, 220.0, 1.6]] \nğ•Ÿ = DMALognormalDistribution(Ax, Î´â‚)\n\nP = [0.5,0.15, 0.10, 0.25]   # Probability of growth factor (4 populations)\ngf = [1.0, 1.2, 1.6, 2.1]    # Values of growth factor\nğ•˜ = mymodel(ğ•Ÿ, P, dma2range[1], gf)\n\nplot(x = ğ•˜.Dp/(dma2range[1]*1e9), y = ğ•˜.N, Geom.line,\n    Guide.xticks(ticks = 0.8:0.2:3),\n    Coord.cartesian(xmin = 0.8, xmax = 3.0))\n\n\n\n\n\n","category":"function"},{"location":"lib/forward/#TDMA1Ddomainfunction","page":"Forward Models","title":"TDMA1Ddomainfunction","text":"","category":"section"},{"location":"lib/forward/","page":"Forward Models","title":"Forward Models","text":"TDMA1Ddomainfunction","category":"page"},{"location":"lib/forward/#DifferentialMobilityAnalyzers.TDMA1Ddomainfunction","page":"Forward Models","title":"DifferentialMobilityAnalyzers.TDMA1Ddomainfunction","text":"TDMA1Ddomainfunction(ğ•Ÿáµ¢â‚™,  Î›â‚áµ¢â‚™ , Î›â‚‚áµ¢â‚™, dma2rangeáµ¢â‚™)\n\nReturns a domain function that can be used with RegularizationTools.jl to create a domain matrix. The inputs are same as for TDMA1Dpdf to compute a model that models the output of a tandem DMA for an  input pdf of growth factors. Tne function and matrix are specialized for a specific size distribution\n\nğ•Ÿáµ¢â‚™ is the size distribution with  Dp sorted in in ascending order and units of nm\nÎ›â‚áµ¢â‚™ , Î›â‚‚áµ¢â‚™ DMA 1 and 2 configuration of type of DMAconfig\ndma2rangeáµ¢â‚™ a tuple (Dd, gmin, gmax, n) where   Dd is the dry diameter selected by DMA 1 in units of m   gmin is the lower range of growth factors scanned by DMA2   gmax is the upper range of growth factor scanned by DMA2   n is the number of bins to represent the DMA2 grid\n\nExample\n\nusing Distributions\nusing DifferentialMobilityAnalyzers\nusing RegularizationTools\nusing Gadfly\n\nt, p = 295.15, 1e5\nqsa, qsh = 1.66e-5, 8.33e-5\nrâ‚, râ‚‚, l = 9.37e-3, 1.961e-2, 0.44369\nÎ›â‚ = DMAconfig(t, p, qsa, qsh, râ‚, râ‚‚, l, 0.0, :-, 6, :cylindrical)\nÎ›â‚‚ = DMAconfig(t, p, qsa, qsh, râ‚, râ‚‚, l, 0.0, :-, 6, :cylindrical)\nğ•Ÿ = lognormal([[9., 40., 1.5], [500., 180., 1.4]]; d1 = 800, d2 = 10.0, bins = 120)\n\n# scan 100 nm Dd from 0.8Dd to 3.0Dd with 100 bins\ndma2range = (100e-9, 0.8, 3.0, 30)\n\n# Get the model function\nmodel = TDMA1Dpdf(ğ•Ÿ, Î›â‚, Î›â‚‚, dma2range)\n\n# Growth factor grid along with the PDF is evaluated over\nmgf = 0.8:0.05:2.5 \n\n# A growth factor PDF\ngfpdf = pdf(truncated(Normal(1.2,0.2) , 1, 17), mgf)\n\n# The output model\nğ•˜ = model(ğ•Ÿ, gfpdf, dma2range[1], mgf)\n\n# The domain function\nf = TDMA1Ddomainfunction(ğ•Ÿ, Î›â‚, Î›â‚‚, dma2range)\n\n# Computes the design matrix\nA = designmatrix(mgf, f)\n\n# Computes the output via matrix multiplication\ng = A*gfpdf\n\n# Compare with the regular model. Note that the matrix method follows the mgf grid.\n# which can be different than the model grid given via dma2range\nplot(layer(x = ğ•˜.Dp/(dma2range[1]*1e9), y = ğ•˜.N), layer(x = mgf, y = g, Geom.line))\n\n\n\n\n\n","category":"function"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Cruz, C. N. and S. N. Pandis (1997). A study of the ability of pure secondary organic aerosol to act as cloud condensation nuclei. Atmospheric Environment 31, 2205â€“2214, DOI:10.1016/S1352-2310(97)00054-X.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Gysel, M., McFiggans, G., and Coe, H. (2009) Inversion of Tandem Differential Mobility Analyser (TDMA) Measurements, Journal of Aerosol Science, 40, 134â€“151, https://doi.org/10.1016/j.jaerosci.2008.07.013.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Hansen, P. C. (2000) The L-Curve and its Use in the Numerical Treatment of Inverse Problems, in Computational Inverse Problems in Electrocardiology, ed. P. Johnston, Advances in Computational Bioengineering, 119-142, WIT Press.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Hagwood, C. (1999) The DMA Transfer Function with Brownian Motion a Trajectory/Monte-Carlo Approach, Aerosol Science & Technology, 30:1, 40-61, DOI:10.1080/027868299304877.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Hinds, W. C. (1999) Aerosol Technology, Properties, Behavior, and Measurement of Airborne Particles, Second Edition, John Wiley & Sons, Inc.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Knutson, E. O. & K. T. Whitby (1975) Aerosol classification by electric mobility: Apparatus, theory, and applications. J. Aerosol Sci. (6)443-451, DOI:10.1016/0021-8502(75)90060-9.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Talukdar, Suddha S. & Mark T. Swihart (2003) An Improved Data Inversion Program for Obtaining Aerosol Size Distributions from Scanning Differential Mobility Analyzer Data, Aerosol Science and Technology, 37:2, 145-161, DOI:10.1080/02786820300952.","category":"page"},{"location":"references/","page":"References","title":"References","text":"TSI Inc. (2009) Series 3080 Electrostatic Classifiers. Operation and Service Manual, P/N 1933792, Revision J March 2009. ","category":"page"},{"location":"references/","page":"References","title":"References","text":"Petters, M. D., A. J. Prenni, S. M. Kreidenweis, P. J. DeMott (2007) On measuring the critical diameter of cloud condensation nuclei using mobility selected aerosol, Aerosol Science & Technology, 41(10), 907-913, doi:10.1080/02786820701557214.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Petters, M. D., C. M. Carrico, S. M. Kreidenweis, A. J. Prenni, P. J. DeMott, J. R. Collett Jr., and H. MoosmÃ¼ller (2009) Cloud condensation nucleation ability of biomass burning aerosol, Journal Geophysical Research, 114, D22205, doi:10.1029/2009JD012353.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Petters, M. D. (2018) A language to simplify computation of differential mobility analyzer response functions, Aerosol Science & Technology, 52:12, 1437-1451, DOI:10.1080/02786826.2018.1530724. ","category":"page"},{"location":"references/","page":"References","title":"References","text":"Rader, D.J. and P.H. McMurry (1986) Application of the tandem differential mobility analyzer to studies of droplet growth or evaporation,Journal of Aerosol Science, 17(5), 771-787,DOI:10.1016/0021-8502(86)90031-5","category":"page"},{"location":"references/","page":"References","title":"References","text":"Reineking A. & J. PorstendÃ¶rfer (1986) Measurements of Particle Loss Functions in a Differential Mobility Analyzer (TSI, Model 3071) for Different Flow Rates, Aerosol Science and Technology, 5:4, 483-486, DOI:10.1080/02786828608959112.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Shen, C., Zhao, G., and Zhao, C. (2020) Effects of Multi-Charge on Aerosol Hygroscopicity Measurement by HTDMA, Atmospheric Measurement Techniques Discussions, 2020, 1â€“15, https://doi.org/10.5194/amt-2020-338.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Snider, J. R., M. D. Petters, P. Wechsler, and P. S. K. Liu, (2006), Supersaturation in the Wyoming CCN instrument, Journal Atmospheric Oceanic Technology, 23, 1323-1339, doi:10.1175/JTECH1916.1. ","category":"page"},{"location":"references/","page":"References","title":"References","text":"Stolzenburg, M. R. & P. H. McMurry (2008) Equations Governing Single and Tandem DMA Configurations and a New Lognormal Approximation to the Transfer Function, Aerosol Science and Technology, 42:6, 421-432, DOI:10.1080/02786820802157823.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Wang, S. C. and Flagan, R. C. (1990). Scanning electrical mobility spectrometer. Aerosol Science and Technology, 13:2, 230â€“240.","category":"page"},{"location":"references/","page":"References","title":"References","text":"Wiedensohler, A. (1988) An approximation of the bipolar charge distribution for particles in the submicron size range, Journal of Aerosol Science, 19:3, 387-389, DOI:10.1016/0021-8502(88)90278-9.","category":"page"},{"location":"notebooks/#Notebooks","page":"Notebooks","title":"Notebooks","text":"","category":"section"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"warning: Warning\nThe notebooks were the original documentation of the project. Most of the material of the notebooks has been incorporated into the Manual section and is reproduced in the Tutorial. The notebooks are linked here for backward compatibility and to cover some content that is not yet included in the Manual section (e.g. the dual tandem DMA) or the FORTRAN integration.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"The project is documented in a journal manuscript. The original submission included 12 Supplementary Jupyter Notebooks. The links open the notebooks in viewer mode via  NBViewer. The notebooks have been edited for compatibility and readability.  A virtual machine with working copies of the originally submitted notebooks are archived on zenodo. Instructions for setting up the  machine are in the supporting information of the manuscript.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Manuscript (Open Access) ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S1. Differential Mobility Analyzer ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook introduces the Differential Mobility Analyzer (DMA) and demonstrates basic  functions. The notebook includes Figures of the schematic of the DMA, the size dependence  of the Cunningham slip flow correction factor, particle diffusion coefficient, penetration  efficiency through the DMA, and the fractional charging efficiency of the bipolar charger.  It also includes examples of the normalized DMA transfer functions.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S2. Fredholm Integral Equation ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook introduces the Fredholm integral equation and derives the discretized  solution via the forward convolution matrix. The notebook demonstrates how the convolution matrix is computed for any set of transmission functions.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S3. Size Distribution Arithmetic ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook introduces the SizeDistribution type. Seven unique operations are defined and showcased: (a) Multiplication of scalar and size distribution, (b) Multiplication of vector and size distribution, (c) Multiplication of matrix and size distribution, (d) Multiplication of size distribution and size distribution, (e) Division of size distribution and size distribution (f) Dot product of scalar and size distribution, (g) Dot product of vector and size distribution, and (h) Addition of two size distributions.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S4. Single Mobility Classification ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates how the software can be used to find the true size distribution of monodisperse mobility selected particles. It also demonstrates how to compute the selected number, surface area, and volume concentration.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S5. Size Distribution Inversion Using Regularization ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates how to invert a size distribution from a measured noisy response function. Application of the convolution matrix together with a Twomey inverse and the L-curve algorithm are used to invert a synthetic dataset.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S6. Size Distribution Inversion of Ambient Data ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook applies the regularized inverse to a published dataset. Results are compared to the inversion output of the manufacturer supplied software and evaluates the degree of agreement between this package and the manufacturer software.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S7. Size resolved CCN measurements ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates calculations related to the the configuration where a single differential mobility analyzer is used together with a condensation particle counter and cloud condensation nuclei counter. It is demonstrated how to express the response function in terms of the language and how to fit the response function to infer the cloud droplet activation diameter.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S8. Hygroscopicity Tandem DMA ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates calculations related to the configuration where the first differential mobility is used as classifier. The output is conditioned in a humidifier and the resulting size distribution is measured using a second DMA in scanning mode together with a condensation particle counter (or other instrument) as detector. It is demonstrated how the language can be used to express the response function of the second differential mobility analyzer used either with or without bipolar charger.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S9. Volatility Tandem DMA ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates calculations related to the configuration where the first differential mobility is used as classifier. The output is conditioned in an evaporator or condenser and the resulting size distribution is measured using a second differential mobility analyzer in scanning mode together with a condensation particle counter (or other instrument) as detector. It is demonstrated how the language can be used to express the response function of the second differential mobility analyzer used either with or without bipolar charger.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S10. Dimer Coagulation and Isolation ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates calculations related to the configuration where two DMAs are used to size select particles of opposite charge. The two populations are merged and allowed to coagulate. Coagulated dimers are isolated using an electrostatic filter. The dimers are charge neutralized and the size distribution is measured using a DMA operated in stepping or scanning mode. It is demonstrated how the language can be used to express the response function of the third differential mobility analyzer.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S11. PartMC Simulations","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook presents an overview over coagulation theory. It is shown how to predict the coagulated distribution using Size Distribution Arithmetic (Notebook S3). The approach is compared to model predictions with the Particle-resolved Monte Carlo code for atmospheric aerosol simulation (PartMC)","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Notebook S12. FORTRAN API ","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"This notebook demonstrates how to construct a convolution matrix using a DMA transfer function defined in a FORTRAN routine. The notebook explains how to compile the routine to a shared library and setup ccall to pass variables to and from the FORTRAN routine.","category":"page"},{"location":"notebooks/","page":"Notebooks","title":"Notebooks","text":"Link to Virtual Machine","category":"page"},{"location":"lib/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"Operators are used to transform size distributions. The operators overload the Base or LinearAlgebra methods. Operators fall into two broad categories: operators changing number concentration and spectral density fields (ğ•Ÿ.N and ğ•Ÿ.S) and operators that change the sizing vector (ğ•Ÿ.Dp). The former include ğ•Ÿâ‚ + ğ•Ÿâ‚‚, ğ•Ÿâ‚ - ğ•Ÿâ‚‚, ğ•Ÿâ‚ âˆ— ğ•Ÿâ‚‚, ğ•Ÿâ‚ / ğ•Ÿâ‚‚, a âˆ— ğ•Ÿ, T .âˆ— ğ•Ÿ, and A âˆ— ğ•Ÿ, while the latter include a Â· ğ•Ÿ and T Â· ğ•Ÿ.","category":"page"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"Operator Description\nğ•Ÿâ‚ + ğ•Ÿâ‚‚ Superposition of the distributions ğ•Ÿâ‚ and ğ•Ÿâ‚‚\nğ•Ÿâ‚ - ğ•Ÿâ‚‚ Superposition of the distributions ğ•Ÿâ‚ and ğ•Ÿâ‚‚\na âˆ— ğ•Ÿ Uniform scaling of the concentration fields by factor a\nğ€ âˆ— ğ•Ÿ Matrix multiplication of ğ€ and concentration\nğ•Ÿâ‚ * ğ•Ÿâ‚‚ Scaled such that total number concentration equals to N1 âˆ— N2\nğ•Ÿâ‚ / ğ•Ÿâ‚‚ Ratio of concentration fields of distributions ğ•Ÿâ‚.N and ğ•Ÿâ‚‚.N\na Â· ğ•Ÿ Uniform scaling of the diameter field of the size distribution by factor a\nT Â· ğ•Ÿ Elementwise scaling the diameter field by factor T\n ","category":"page"},{"location":"lib/operators/#Index","page":"Operators","title":"Index","text":"","category":"section"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"Pages = [\"operators.md\"]","category":"page"},{"location":"lib/operators/#Number-Operators","page":"Operators","title":"Number Operators","text":"","category":"section"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"+(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)","category":"page"},{"location":"lib/operators/#Base.:+-Tuple{SizeDistribution,SizeDistribution}","page":"Operators","title":"Base.:+","text":"+(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)\n\nDefines the sum of two size distributions. If diameter grids are not equal, then the diameter grid of n2 is interpolated onto the n1 grid prior to addition.\n\nğ•© = ğ•Ÿâ‚ + ğ•Ÿâ‚‚ \n\nis defined such that \n\nğ•©.S = ğ•Ÿâ‚.S + ğ•Ÿâ‚‚.S \nğ•©.N = ğ•©.S .* ğ•Ÿ.Î”lnD \n\nExample Usage\n\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 64)\nğ•© = ğ•Ÿâ‚ + ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"-(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)","category":"page"},{"location":"lib/operators/#Base.:--Tuple{SizeDistribution,SizeDistribution}","page":"Operators","title":"Base.:-","text":"-(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)\n\nDefines the sum of two size distributions. If diameter grids are not equal, then the diameter grid of n2 is interpolated onto the n1 grid prior to addition.\n\nğ•© = ğ•Ÿâ‚ - ğ•Ÿâ‚‚ \n\nis defined such that \n\nğ•©.S = ğ•Ÿâ‚.S - ğ•Ÿâ‚‚.S \nğ•©.N = ğ•©.S .* ğ•Ÿ.Î”lnD \n\nExample Usage\n\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 64)\nğ•© = ğ•Ÿâ‚ - ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"*(a::Number, ğ•Ÿ::SizeDistribution)","category":"page"},{"location":"lib/operators/#Base.:*-Tuple{Number,SizeDistribution}","page":"Operators","title":"Base.:*","text":"*(a::Number, ğ•Ÿ::SizeDistribution)\n\nMultiplication of scalar and size distribution. The net result is a scaling of the  number concentration of the spectra by a. The function is symmetric such that a * ğ•Ÿ == ğ•Ÿ * a.\n\nLet a denote a number and ğ•Ÿ denote a size distribution. Then\n\nğ•© = a * ğ•Ÿ \n\nis defined such that\n\nğ•©.N = a * ğ•Ÿ.N\nğ•©.S = a * ğ•Ÿ.S\n\nExample Usage\n\nğ•Ÿ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•© = 2.3 * ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"*(ğ€::AbstractMatrix, ğ•Ÿ::SizeDistribution)","category":"page"},{"location":"lib/operators/#Base.:*-Tuple{AbstractArray{T,2} where T,SizeDistribution}","page":"Operators","title":"Base.:*","text":"*(ğ€::AbstractMatrix, ğ•Ÿ::SizeDistribution)\n\nMultiplication of matrix and size distribution. The net result is the multiplication of the  matrix with number concentration and spectral density fields. \n\nLet ğ€ denote an nxn matrix where n equals the number of size bins of ğ•Ÿ. Then\n\nğ•© = ğ€ * ğ•Ÿ \n\nis defined such that \n\nğ•©.N = ğ€ * ğ•Ÿ.N\nğ•©.S = ğ€ * ğ•Ÿ.S\n\nğ•Ÿ = lognormal([[100, 100, 1.1]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ€ = rand(256,256)\nğ•© = ğ€ * ğ•Ÿ                                        \n\n\n\n\n\n","category":"method"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"*(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)","category":"page"},{"location":"lib/operators/#Base.:*-Tuple{SizeDistribution,SizeDistribution}","page":"Operators","title":"Base.:*","text":"*(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)\n\nMultiplication of size distribution and a size distribution. The net result is a  size distribution that has total number concentration square. For a probability  distributions that by definition integrate to unity, this operation corresponds to  the product of two random variates with distribution 1 and 2.\n\nLet ğ•Ÿâ‚ and ğ•Ÿâ‚‚ denote a two size distribution defined on the same diameter grid. Then\n\nğ•© = ğ•Ÿâ‚ * ğ•Ÿâ‚‚ \n\nis defined such that \n\nNsq = ğ•Ÿâ‚.N * ğ•Ÿâ‚‚.N\nğ•©.N = sum(ğ•Ÿâ‚.N) * sum(ğ•Ÿâ‚‚.N) * Nsq./sum(Nsq)\nğ•©.S = N ./ ğ•Ÿâ‚.Î”dlnD\n\nExample Usage\n\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 64)\nğ•© = ğ•Ÿâ‚ * ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"/(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)","category":"page"},{"location":"lib/operators/#Base.:/-Tuple{SizeDistribution,SizeDistribution}","page":"Operators","title":"Base.:/","text":"/(ğ•Ÿâ‚::SizeDistribution, ğ•Ÿâ‚‚::SizeDistribution)\n\nDivision of size distribution and size distribution. The net result is a size distribution  that is the ratio of the concentration vectors.\n\nLet ğ•Ÿâ‚ and ğ•Ÿâ‚‚ denote a two size distribution defined on the same diameter grid. Then\n\nğ•© = ğ•Ÿâ‚ / ğ•Ÿâ‚‚\n\nis defined such that\n\nN = ğ•Ÿâ‚.N ./ ğ•Ÿâ‚‚.N\nS = ğ•Ÿâ‚.S ./ ğ•Ÿâ‚‚.S\n\nExample Usage\n\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 64)\nğ•© = ğ•Ÿâ‚ / ğ•Ÿâ‚‚\n\n\n\n\n\n","category":"method"},{"location":"lib/operators/#Size-Operators","page":"Operators","title":"Size Operators","text":"","category":"section"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"LinearAlgebra.:â‹…(a::Number, ğ•Ÿ::SizeDistribution)","category":"page"},{"location":"lib/operators/#LinearAlgebra.:â‹…-Tuple{Number,SizeDistribution}","page":"Operators","title":"LinearAlgebra.:â‹…","text":"â‹…(a::Number, ğ•Ÿ::SizeDistribution)\n\nMultiplication of a scalar and a size distribution. The net result is a uniform diameter  shift of the size distribution. The function is symmetric such that a â‹… ğ•Ÿ == ğ•Ÿ â‹… a.\n\nLet a denote a floating point scalar and ğ•Ÿ denote a size distribution. Then\n\nğ•© = a â‹… ğ•Ÿ\n\nis defined such that \n\nğ•©.Dp = a * ğ•Ÿ.Dp \n\nExample Usage\n\na = 2.0 \nğ•Ÿ = lognormal([[300, 100, 1.3]]; d1 = 10.0, d2 = 1000.0, bins = 256)\nğ•© = a â‹… ğ•Ÿ \n\n\n\n\n\n","category":"method"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"LinearAlgebra.:â‹…(A::Vector{<:AbstractFloat}, ğ•Ÿ::SizeDistribution)","category":"page"},{"location":"lib/operators/#LinearAlgebra.:â‹…-Tuple{Array{var\"#s20\",1} where var\"#s20\"<:AbstractFloat,SizeDistribution}","page":"Operators","title":"LinearAlgebra.:â‹…","text":"LinearAlgebra.:â‹…(A::Vector{<:AbstractFloat}, ğ•Ÿ::SizeDistribution)\n\nDot product of vector and size distribution.   The net result is diameter dependent shift of  the size distribution. The function is symmetric such that A â‹… ğ•Ÿ == ğ•Ÿ â‹… A.\n\nLet T denote a floating point vector with the same number of elements as the size distribution ğ•Ÿ. Then\n\nğ•© = T â‹… ğ•Ÿ \n\nis defined such that \n\nğ•©.Dp = T .* ğ•Ÿ.dp \n\nExample Usage\n\nğ•Ÿ = lognormal([[100, 100, 1.1]]; d1 = 10.0, d2 = 1000.0, bins = 256)  \nÎ¼,Ïƒ = 80.0, 2000.0\nT = (1.0 .+ erf.((ğ•Ÿ.Dp .- Î¼)./(sqrt(2Ïƒ)))) \nğ•© = T â‹… ğ•Ÿ  \n\n\n\n\n\n","category":"method"},{"location":"man/sizedistribution/#Size-Distributions","page":"Size Distributions","title":"Size Distributions","text":"","category":"section"},{"location":"man/sizedistribution/#Notation","page":"Size Distributions","title":"Notation","text":"","category":"section"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"By convention blackboard bold characters denote size distributions","category":"page"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"info: Info\nBlackboard bold font: ğ•’, ğ•“, ğ•”, ğ••, ğ•–, ğ•—, ğ•˜, ...","category":"page"},{"location":"man/sizedistribution/#Histogram-Representation","page":"Size Distributions","title":"Histogram Representation","text":"","category":"section"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"The size distribution is represented as a histogram. It is a composite data type SizeDistribution that has the fields Dp, De, Î”lnD, S, and N. ","category":"page"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"ğ•Ÿ.Dp: Geometric midpoint diameters\nğ•Ÿ.De: Bin edge diameters\nğ•Ÿ.Î”lnD: Log bin spacing, Î”lnD = ln(Dup/Dlow)\nğ•Ÿ.S: Spectral density\nğ•Ÿ.N: Number concentration in the bin","category":"page"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"The size distribution can be constructed various ways. The easiest is to use one of the constructor functions. For example, the lognormal function creates a lognormal size distribution. The following example creates a lognormal size distribution with number concentration equals 200 cm-3, geometric mode diameter of 80 nm, geometric standard deviation of 1.2, with 10 size bins between 30 and 300 nm. The result is placed in a DataFrame for display purposes. The r function is to round the results for clarity. The output illustrates that the SizeDistribution type is simply a histagram table.","category":"page"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"using DifferentialMobilityAnalyzers, DataFrames # hide\nr(x) = round.(Int,x)    # Function to round and convert to Int\nğ•Ÿ = lognormal([[200, 80, 1.2]]; d1 = 30.0, d2 = 300.0, bins = 10);\nDataFrame(\n    Dlow = r(ğ•Ÿ.De[1:end-1]),\n    Dup = r(ğ•Ÿ.De[2:end]),\n    Î”lnD = round.(ğ•Ÿ.Î”lnD, digits = 2),\n    Dp = r(ğ•Ÿ.Dp),\n    S = r(ğ•Ÿ.S),\n    N = r(ğ•Ÿ.N),\n)","category":"page"},{"location":"man/sizedistribution/#Manipulating-Size-Distributions","page":"Size Distributions","title":"Manipulating Size Distributions","text":"","category":"section"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"Size distributions can be intuitively manipulated through operators. For example, the sum of two size distributions (ğ•© = ğ•Ÿâ‚ + ğ•Ÿâ‚‚) is the superposition. ","category":"page"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"using DifferentialMobilityAnalyzers, Gadfly, DataFrames, Printf # hide\n# Example addition of size distributions\nğ•Ÿâ‚ = lognormal([[120, 90, 1.20]]; d1 = 10.0, d2 = 1000.0, bins = 256)   # size distribution\nğ•Ÿâ‚‚ = lognormal([[90, 140, 1.15]]; d1 = 20.0, d2 = 800.0, bins = 256)    # size distribution\nğ•© = ğ•Ÿâ‚ + ğ•Ÿâ‚‚\n# hide\nfunction getplots1(ğ•Ÿâ‚, ğ•Ÿâ‚‚, ğ•©)# hide\n    df1 = DataFrame(Dp = ğ•Ÿâ‚.Dp, S = ğ•Ÿâ‚.S, Dist = [\"ğ•Ÿâ‚\" for i = 1:length(ğ•Ÿâ‚.Dp)])# hide\n    df2 = DataFrame(Dp = ğ•Ÿâ‚‚.Dp, S = ğ•Ÿâ‚‚.S, Dist = [\"ğ•Ÿâ‚‚\" for i = 1:length(ğ•Ÿâ‚‚.Dp)])# hide\n    df3 = DataFrame(Dp = ğ•©.Dp, S = ğ•©.S, Dist = [\"ğ•©\" for i = 1:length(ğ•©.Dp)]) # hide\n    df = [df1; df2; df3] # hide\n # hide\n    xlabels = log10.([40, 100, 400]) # hide\n    colors = [\"darkred\", \"steelblue3\", \"black\"] # hide\n# hide\n    set_default_plot_size(16cm, 9cm) # hide\n    return plot( # hide\n        df, # hide\n        x = :Dp, # hide\n        y = :S, # hide\n        color = :Dist, # hide\n        Geom.step, # hide\n        Guide.xlabel(\"Particle diameter (nm)\"), # hide\n        Guide.ylabel(\"dN/dlnD (cm-3)\"), # hide\n        Guide.xticks(ticks = log10.([40, 50, 60, 70, 80, 90, 100, 200, 300, 400])), # hide\n        Guide.colorkey(; title = \"Distribution\"), # hide\n        Scale.x_log10(labels = x -> x in xlabels ? @sprintf(\"%2i\", exp10(x)) : \"\"), # hide\n        Scale.color_discrete_manual(colors...), # hide\n        Coord.cartesian(xmin = log10(40), xmax = log10(400)), # hide\n    ) # hide\nend # hide\n\ngetplots1(ğ•Ÿâ‚, ğ•Ÿâ‚‚, ğ•©) # hide","category":"page"},{"location":"man/sizedistribution/","page":"Size Distributions","title":"Size Distributions","text":"The package implements a list of Operators for size distribution manipulation. Check out the Tutorial Session 1 and/or Notebook S3 in the Notebooks section for visualizations.","category":"page"},{"location":"lib/physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"The following functions are used to define the physics of the instrument. ","category":"page"},{"location":"lib/physics/#Index","page":"Physics","title":"Index","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"Pages = [\"physics.md\"]","category":"page"},{"location":"lib/physics/#Functions","page":"Physics","title":"Functions","text":"","category":"section"},{"location":"lib/physics/#Fluid-Viscosity","page":"Physics","title":"Fluid Viscosity","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"Î·(Î›::DMAconfig)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.Î·-Tuple{DMAconfig}","page":"Physics","title":"DifferentialMobilityAnalyzers.Î·","text":"Î·(Î›::DMAconfig)\n\nÎ· is the viscosity of air in [Pa s] and depends on temperature [K]. Temperature  is taken from the DMA configuration. Currently only dry air is supported.\n\neta = 183245times10^-5 exp left(15 ln leftfracT2961rightright)left  (frac40655T+1104 right) \n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nviscosity = Î·(Î›)\n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#Cunningham-Correction-Factor","page":"Physics","title":"Cunningham Correction Factor","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"cc(Î›::DMAconfig, d)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.cc-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.cc","text":"cc(Î›::DMAconfig, d)\n\nCunningham slip-flow correction factor. The slip flow correction accounts for the  decreased drag particles experience relative to Stokes' drag force when particle  size approaches the scale of the mean free path of air. It is computed following  Hinds (1999) Eq. 3.20. Temperature and pressure are taken from the DMA configuration. The units of diameter are in [m] and the function accepts scalars or arrays.\n\nc_c = 1+fraclambdad_p left(234+105 exp left-039 fracd_plambdarightright)\n\nwhere d_p is the particle diameter and lambda is the mean  free path of air, which is computed as a function of pressure and temperature. \n\nExample Usage\n\nDp = exp10.(range(log10(1e-9), stop=log10(1000e-9), length=100))\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                    \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \ncorrection = cc(Î›, Dp)\n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#Diffusion-Coefficient","page":"Physics","title":"Diffusion Coefficient","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"dab(Î›::DMAconfig, d)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.dab-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.dab","text":"dab(Î›::DMAconfig, d)\n\nThe diffusion coefficient of particles in air, d_ab, describes the random  displacement of particles due to Brownian motion. It is computed via the Stokes-Einstein  relation (Hinds, 1999, Eq. 7.20). Temperature and pressure are taken from the DMA  configuration. The units of diameter are in [m] and the function accepts scalars or arrays.\n\nd_ab = frack_bTc_c3pieta d_p\n\nwhere k_b is Boltzmann's constant and eta is the viscosity of air in [Pa s],  c_c is the Cunningham slip flow correction and d_p is the particle diameter. d_ab is in [mÂ² sâ»Â¹].\n\nExample Usage\n\nDp = exp10.(range(log10(1e-9), stop=log10(1000e-9), length=100))\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \ndiffusion_coefficient = dab(Î›,Dp)\n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#dtoz","page":"Physics","title":"dtoz","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"dtoz(Î›::DMAconfig, d)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.dtoz-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.dtoz","text":"dtoz(Î›::DMAconfig, d)\n\nThe function returns the mobility z according to  \n\nd_p =  frackec_c3pi eta z^s\n\nwhere e is the elementary charge,  k is the number of charges on the particle,  c_c is the Cunningham correction factor, and eta is the viscosity of the fluid.  The diameter in dtoz is in units of [m].\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nmobility = dtoz(Î›,dp*1e-9) # [m2 V-1 s-1]\n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#ztod","page":"Physics","title":"ztod","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"ztod","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.ztod","page":"Physics","title":"DifferentialMobilityAnalyzers.ztod","text":"ztod(Î›::DMAconfig, i::Int, z)\n\nConverts mobility to diameter.\n\nÎ› is the DMA configuration\ni is the number of charges\nz is the mobility\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nz = dtoz(Î›,100.0*1e-9) \ndiameter = ztod(Î›,1,z) \n\n\n\n\n\n","category":"function"},{"location":"lib/physics/#vtoz","page":"Physics","title":"vtoz","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"vtoz(Î›::DMAconfig, v)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.vtoz-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.vtoz","text":"vtoz(Î›::DMAconfig, v)\n\nConverts between voltage and selected mobility. It is the inverse of ztov. \n\nFor the cylindrical DMA and balanced flows: \n\nz^s = fracq_sh2pi l v ln left(fracr_2r_1right)\n\nFor the radial DMA and balanced flows:\n\nz^s = fracq_sh lpi v left(r_2^2 - r_1^2right)\n\nwhere v is the potential applied between the inner and out section of the annulus,  r_1, r_2, and l are the dimensions of the cylindrical DMA  and q_sh is  the sheath flow rate.\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5\nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nmobility = vtoz(Î›,1000.0) # [m2 V-1 s-1]\n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#ztov","page":"Physics","title":"ztov","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"ztov(Î›::DMAconfig, z)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.ztov-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.ztov","text":"ztov(Î›::DMAconfig, v)\n\nConverts between selected mobility and voltage. It is the inverse of vtoz. \n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5\nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nvoltage = ztov(Î›,1e-9) \n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#gfâ‚–","page":"Physics","title":"gfâ‚–","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"gfâ‚–(Î›, zË¢, gf, k)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.gfâ‚–-NTuple{4,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.gfâ‚–","text":"gfâ‚–(Î›, zË¢, gf, k)\n\nReturns the effective growth factor for multi-charge particles. \n\nÎ›  - DMA configuration \nzË¢ - the dry particle diameter mobility [m2 s-1 V-1]\ngf - the true growth factor\nk  - the number of charges    \n\nThe effect is described by Gysel et al. (2009) and Shen et al. (2020).  Shen et al. (2020) write: \"For electrical mobility diameter of 100 nm, the doubly and  triply charged particles are about 151 nm and 196 nm, respectively. When all these three  kind of particles have a true growth factor of 1.6, they will grow to the size of 160 nm,  242 nm and 314 nm. Since the number of charges they carry remain the same as before,  their peak sizes in the second DMA are around 160 nm, 154 nm and 150 nm. Therefore, the  growth factors they display in the HTDMA measurement is 1.6, 1.54 and 1.5, respectively.\"\n\nExample use\n\n# Define a DMA\nt, p = 295.15, 1e5\nqsa, qsh = 1.66e-5, 8.33e-5\nrâ‚, râ‚‚, l = 9.37e-3, 1.961e-2, 0.44369\nÎ› = DMAconfig(t, p, qsa, qsh, râ‚, râ‚‚, l, 0.0, :-, 6, :cylindrical)\n\nzË¢ = dtoz(Î›, 100e-9) # mobility z-star for 100 nm particle \ntruegf = 1.6          # true growth factor of 1.6\ngfâ‚–(Î›, zË¢, truegf, 1)    # effective growth factor for 1 charge = 1.6\ngfâ‚–(Î›, zË¢, truegf, 2)    # effective growth factor for 2 charges = 1.544 \ngfâ‚–(Î›, zË¢, truegf, 3)    # effective growth factor for 3 charges = 1.507 \ngfâ‚–(Î›, zË¢, truegf, 4)    # effective growth factor for 4 charges = 1.481 \n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#Transfer-Function","page":"Physics","title":"Transfer Function","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"Î©(Î›::DMAconfig, Z, zs)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.Î©-Tuple{DMAconfig,Any,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.Î©","text":"Î©(Î›::DMAconfig, Z, zs)\n\nThe DMA transfer function is the probability that a particle of a particle of a given size  exits the classifier via the sample flow. The diffusive broadened DMA transfer function is  computed assuming blanced sheath and excess flows using the expression of Stolzenburg  and McMurry (2008).\n\nOmega(tildezbetasigma) = fracsigmasqrt2betaleftepsilon left(      fractildez-(1+beta)sqrt2sigma right) + epsilon left (fractildez-     (1-beta)sqrt2sigma right) - 2epsilon left      ( fractildez-1sqrt2sigmaright)  right\n\nwhere tildez = fraczz^s is the dimensionless mobility, z is the particle  mobility z^s is the centroid mobility selected by the DMA,  epsilon = x mathrmerf(x) +left(exp(-x^2)sqrtpiright), mathrmerf is  the error function, and beta = fracq_saq_sh. The parameter sigma  accounts for diffusional broading of the transfer function. Assuming plug flow,  sigma can be computed using the following equations Hagwood (1999) \n\ngamma = left(fracr_1r_2right)^2\n\nI = frac12(1+Î³)\n\nkappa = fraclr_2r_2^2-r_1^2\n\nG = frac4(1+beta)^2(1-Î³) leftI+2(1+beta)kappa^-2 right \n\nsigma = sqrtfrac2Gpi ld_abq_sh\n\nInputs for flow are taken from the DMAconfig. The function expects a mobility scalar z or vector Z, and a centroid mobility zË¢.\n\nExample Usage\n\nzË¢ = dtoz(Î›, 200e-9)      # centroid mobility for Dp = 200 nm\nz = [1e-9, 1e-8, 1e-7]    # mobility \nÎ©(Î›,z,zË¢)                 # Output of the transfer function\n\nnote: Note\nThe function Î© is embedded in the the Type DifferentialMobilityAnalyzers.jl, which  assigns Î´.Î© either to this function Î© or Î©av applicable to scanning mode,\n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#Charging-Probability","page":"Physics","title":"Charging Probability","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"getTc(Î›::DMAconfig)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.getTc-Tuple{DMAconfig}","page":"Physics","title":"DifferentialMobilityAnalyzers.getTc","text":"getTc(Î›::DMAconfig)\n\nReturns a function \n\nTc(k::Integer, Dp)\n\nto compute the charging efficiency. Tc depends of the polarity set in DMAconfig.\n\nCharging efficiency (charge equilibrium) obtained in the bipolar charger is computed based  on the parameterized measurements by Wiedensohler et al. (1988) with coefficients taken  from the TSI 3080 Manual (2009). \n\nT_c(k) = 10^left sum_i=1^6 a_i (k) left ln left(fracD_pnmright) right^i-1 right\n\nwhere k = -2-112 is the number and polarity of particle charge and a_i are  empirical coefficients. \n\nFor k ge pm 3, the formula from the TSI manual is used:\n\nT_c(k) = fracesqrt4pi^2epsilon D_pk_bT exp left( frac-fracleftk -  2piepsilon D_pk_bT ln(0875)right^2e^2 frac4piepsilon D_pk_bTe^2 right)\n\nwhere e is the elementary charge and epsilon is the dielectric constant for air.\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nTc = getTc(Î›)\nTc(1,100.0) # Note that Dp is in units of nm!\n\nnote: Note\nThe function Tc is computed during DMA grid initialization and embedded in the  DifferentialMobilityAnalyzer data type. It is usually accessed through this grid. The diameter Dp is in units of nm.\n\n\n\n\n\n","category":"method"},{"location":"lib/physics/#Transmission-Loss","page":"Physics","title":"Transmission Loss","text":"","category":"section"},{"location":"lib/physics/","page":"Physics","title":"Physics","text":"Tl(Î›::DMAconfig, Dp)","category":"page"},{"location":"lib/physics/#DifferentialMobilityAnalyzers.Tl-Tuple{DMAconfig,Any}","page":"Physics","title":"DifferentialMobilityAnalyzers.Tl","text":"Tl(Î›::DMAconfig, Dp)\n\nPenetration efficiency through the TSI cylindrical DMA using the parameterization by  Reineking & PorstendÃ¶rfer (1986). The particle diameter Dp is in [nm].\n\nT_l = 082exp(-115u)+01exp(-700u)+003exp(-1800u)+002exp(-3400u)\n\nwhere u = fracd_ab l_effq_sa l_eff is the parameterized effective  diffusion length, and q_sa is the aerosol flow rate through the DMA. \n\nnote: Note\nÎ› contains the effective length, aerosol flow rate, temperature and pressure to  compute d_ab. To treat multiple DMAs with different {leff, qsa,  t, p} in a single script, the function Tl is  embedded  in the  DifferentialMobilityAnalyzer data type.\n\n\n\n\n\n","category":"method"},{"location":"man/dmas/#Initializing-DMAs","page":"Initializing DMAs","title":"Initializing DMAs","text":"","category":"section"},{"location":"man/dmas/#Notation","page":"Initializing DMAs","title":"Notation","text":"","category":"section"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"This package is designed to work with chained DMA systems. To isolate individual DMA systems, the instruments are abstracted into the data types DMAconfig and DifferentialMobilityAnalyzer. By convention variables of type DMAconfig are assigned the letter Î› and variables of type DifferentialMobilityAnalyzer the letter Î´. Subscripts or superscripts can be used to distinguish DMA1, DMA2, ... That is Î›â‚, Î›â‚‚, ... and Î´â‚, Î´â‚‚, ...","category":"page"},{"location":"man/dmas/#DMA-Configuration","page":"Initializing DMAs","title":"DMA Configuration","text":"","category":"section"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"The DMA is an annular capacitor. The column's properties are defined by the radii r_1, r_2, the length of the aerosol path, l. Operation conditions are defined by the the electric potential v applied across the annulus and the four flow rates: sheath flow, q_sh, polydisperse aerosol flow q_a, excess flow, q_ex, and monodisperse sample flow, q_sa. Throughout this work it is assumed that the flows are balanced, i.e. q_sh = q_ex and q_sa = q_a. The two flows tracked are q_sh and q_sa.","category":"page"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"Here is an example initialization of the DMAconfig","category":"page"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"using DifferentialMobilityAnalyzers              \n\nqsa,qsh = 1.66e-5, 8.33e-5                       # Qsample [m3 s-1], Qsheath [m3 s-1]\nt,p = 295.15, 1e5                                # Temperature [K], Pressure [Pa]\nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               # DMA geometry [m]\nleff = 13.0                                      # DMA effective diffusion length [m]\nm = 6                                            # Upper number of charges to consider\nDMAtype = :cylindrical                           # specify DMA type as cylindrical or radial\npolarity = :-                                    # negative :- or positive :+ polartiy\n\nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,leff,polarity,m,DMAtype)  ","category":"page"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"The data type Î› defines the DMA in terms of flow rates, geometry and power supply polarity. The geometry parameters used in this example correspond to the TSI 3080 long column. The effective diffusion length describes Transmission Loss in the DMA column. Diffusional loss is ignored if leff = 0. The DMA configuration is used to cross reference to the appropriate Fluid Viscosity, Cunningham Correction Factor, Diffusion Coefficient, particle Charging Probability, and DMA Transfer Function for the given thermodynamic state and fluid velocity. Check out the Tutorial Session 1 and/or Notebook S1 in the Notebooks section for visualizations.","category":"page"},{"location":"man/dmas/#DMA-Grid","page":"Initializing DMAs","title":"DMA Grid","text":"","category":"section"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"The DMA grid encodes the actual operation of the instrument. The DMA is operates between an upper and lower voltage limit. The full range is usually 10V to 10kV. At higher voltages the electric field breaks down. A convenient way to bin the DMA is to work with a log spaced mobility grid, which in essence is the size distribution histogram where diameters are computed using ztod. ","category":"page"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"The DMA grid is instantiated using one of the contructor functions: setupDMA, setupSMPS, setupSMPSdata. Each of these defines the lower and upper size limit and the number of bins of the grid. ","category":"page"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"using DifferentialMobilityAnalyzers              # hide\nqsa,qsh = 1.66e-5, 8.33e-5                       # hide\nt,p = 295.15, 1e5                                # hide\nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               # hide\nleff = 13.0                                      # hide\nm = 6                                            # hide\nDMAtype = :cylindrical                           # hide\npolarity = :-                                    # hide\nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,leff,polarity,m,DMAtype) # hide  \nbins,zâ‚,zâ‚‚ = 60, vtoz(Î›,10000), vtoz(Î›,10)    # bins, upper, lower mobility limit\nÎ´ = setupDMA(Î›, zâ‚, zâ‚‚, bins);                # Setup DMA grid","category":"page"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"The resulting type Î´ contains ","category":"page"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"Z are the mobility bin midpoints, \nDp are the diameter bin midpoints (internally in units of nm) \nZe are the mobility bin edges, \nDe are the diameter bin edges, \nÎ”lnD is the natural log ratio of upper and lower diameter bin edge\nthe matrices ğ€, ğ’, ğ, ğˆ used in the size distribution Inversion Routines\nthe function Î© (Transfer Function), Tc (Charging Probability), Tl (Transmission Loss)","category":"page"},{"location":"man/dmas/","page":"Initializing DMAs","title":"Initializing DMAs","text":"Check out the Tutorial Session 1 and/or Notebook S1 in the Notebooks section for visualizations.","category":"page"},{"location":"lib/benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"lib/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Functions to compute benchmarks.","category":"page"},{"location":"lib/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"benchmark(bins::Integer, num_threads::Integer)","category":"page"},{"location":"lib/benchmarks/#DifferentialMobilityAnalyzers.benchmark-Tuple{Integer,Integer}","page":"Benchmarks","title":"DifferentialMobilityAnalyzers.benchmark","text":"benchmark(bins::Integer, num_threads::Integer)\n\nComputes benchmarks for the three slowest operations, rinv, setupDMA, setupSMPS\n\nbins is the number of DMA bins\nnum_threads is the number of BLAS threads\n\nThe function returns a dataframe that includes cpuinfo, juliaversion, blasvendor, blasthreads, number of bins, and the three timed benchmarks for rinv, setupDMA, setupSMPS.\n\n\n\n\n\n","category":"method"},{"location":"lib/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"runbenchmarks()","category":"page"},{"location":"lib/benchmarks/#DifferentialMobilityAnalyzers.runbenchmarks-Tuple{}","page":"Benchmarks","title":"DifferentialMobilityAnalyzers.runbenchmarks","text":"runbenchmarks()\n\nRuns a set of standard benchmarks, varying the number bins and returns a dataframe with results. This function may take several minutes to complete. \n\n\n\n\n\n","category":"method"},{"location":"man/benchmarks/#Performance-Benchmarks","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"man/benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Currently best performance is achieved running on a single BLAS threads (set as default) and the using the Intel MKL linear algebra library. The MKL library is not shipped in the default Julia distribution must be manually installed.","category":"page"},{"location":"man/benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Benchmarks can be computed using supplied functions. Running the benchmark test will take some time since the routine takes an average of multiple runs and cycles through several configurations.","category":"page"},{"location":"man/benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"The three slowest routines included in the benchmark are rinv, setupDMA, and setupSMPS. Setting up the DMAs is a one-time computational cost. If speed is absolutely critical, the fields Î› and Î´ can be precomputed and loaded from file. The computational cost of rinv is recurring.","category":"page"},{"location":"man/benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Example benchmark run:","category":"page"},{"location":"man/benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"using DifferentialMobilityAnalyzers\nrunbenchmarks()","category":"page"},{"location":"man/inverse/#Inverse-Models","page":"Inverse Models","title":"Inverse Models","text":"","category":"section"},{"location":"man/inverse/#Size-Distribution-Inversion","page":"Inverse Models","title":"Size Distribution Inversion","text":"","category":"section"},{"location":"man/inverse/#Theory","page":"Inverse Models","title":"Theory","text":"","category":"section"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"The size distribution can be found from the inverse of the response function using Tikhonov regularization.","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"L_1 and L_2 are the Euclidian norms of the solution and the intial guess. ","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"L_1 = leftlVert bfArmğ•Ÿ - rmğ•£rightrVert_2","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"L_2 = leftlVertbfL(rmğ•Ÿ - rmğ•Ÿ_i)rightrVert_2","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"where rmğ•Ÿ is the true size distribution, bfA is the convolution matrix, ğ•£ is the measured response vector, bfL is a weights matrix, and rmğ•Ÿ_i is an initial guess. To solve for the inverse, a balance is sought between the L_1 and L_2 norms.","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"ğ•Ÿ_inv = arg minL_1^2 + lambda^2 L_2^2","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"where lambda is the regularization parameter. Taking bfL = bfI (weight matrix equals the identity Matrix ğˆ) and rmğ•Ÿ_i = bfS^-1rmğ•£ as initial guess (Matrix ğ’), the regularized inverse is computed via:","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"ğ•Ÿ_inv = (bfA^rmTbfA + lambda^rm2 bfI)^rm-1(bfA^rmT rmğ•£ + lambda^2bfS^-1 rmğ•£)","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"The regularization parameter lambda \"interpolates\" between the noisy least-square inverse (lambda = 0) and the initial guess (lambda  1). The optimal regularization parameter is found using the L-curve method. The optimal lambda_opt is found using the L-curve method. The L-curve is defined as a plot of log(L_1) vs.  log(L_2), where L_1 and L_2 are obtained for a series of discrete lambda values. The lambda_opt is found at the corner of the L-curve, which is mathematically defined as the point where where the curvature of the L-curve is maximum. Here, the corner of the L-curve is found using the iterative algorithm described in Talukdar and Swihart (2003). The curvature is calculated using Eq. (14) in Hansen (2000), which requires the first and second derivatives of dln(L_i)^2dlambda. These derivatives of dln(L_i)^2dlambda are estimated numerically.","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"See session 3 of the Tutorial for an interactive explanation on how Tikhonov regularization works.","category":"page"},{"location":"man/inverse/#Example","page":"Inverse Models","title":"Example","text":"","category":"section"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"The L-curve search method is implemented in the rinv function. Also check out the new rinv2 function, which has much faster performance and is based on generalized cross validation. It also allows to specify higher order inversions. The default implementation gives near identical results to rinv. ","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"ğ•Ÿâ±â¿áµ› = rinv(ğ•£.N, Î´, Î»â‚=0.1, Î»â‚‚=1.0);","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"The function takes the response vector to be inverted, the DMA grid to read the matrices, and an upper and lower search bound for the optimal regularization parameter. ","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"using DataFrames, Gadfly, CSV, Printf, DifferentialMobilityAnalyzers #hide\n#hide\ndf = CSV.read(\"example_data.csv\", DataFrame) \n\nt, p, lpm = 293.15, 940e2, 1.666e-5 \nrâ‚, râ‚‚, l = 9.37e-3,1.961e-2,0.44369     \nÎ› = DMAconfig(t,p,1lpm,4lpm,râ‚,râ‚‚,l,0.0,:+,6,:cylindrical)  \nÎ´ = setupDMA(Î›, vtoz(Î›,10000), vtoz(Î›,10), 120) \n\nğ•£ = (df,:Dp,:Rcn,Î´) |> interpolateDataFrameOntoÎ´ \nğ•Ÿâ±â¿áµ› = rinv(ğ•£.N, Î´, Î»â‚=0.1, Î»â‚‚=1.0)\nğ•Ÿâ±â¿áµ›Â² = rinv2(ğ•£.N, Î´, Î»â‚=0.1, Î»â‚‚=1.0)\n \ndf1 = DataFrame(Dp = ğ•Ÿâ±â¿áµ›.Dp, S = ğ•Ÿâ±â¿áµ›.S, Dist = [\"ğ•Ÿâ±â¿áµ›\" for i = 1:length(ğ•Ÿâ±â¿áµ›.Dp)]) #hide\ndf2 = DataFrame(Dp = ğ•Ÿâ±â¿áµ›Â².Dp, S = ğ•Ÿâ±â¿áµ›Â².S, Dist = [\"ğ•Ÿâ±â¿áµ›Â²\" for i = 1:length(ğ•Ÿâ±â¿áµ›Â².Dp)]) #hide\ndf = [df1;df2] #hide\ndfr = DataFrame(Dp = ğ•£.Dp, S = ğ•£.N, Dist = [\"ğ•£\" for i = 1:length(ğ•£.Dp)])#hide\n#hide\nxlabels = log10.([10, 100, 500])#hide\ncolors = [\"darkred\", \"steelblue3\", \"black\"]#hide\np1 = plot(#hide\n    dfr,#hide\n    x = :Dp,#hide\n    y = :S,#hide\n    color = :Dist,#hide\n    Geom.step,#hide\n    Guide.xlabel(\"Particle diameter (nm)\"),#hide\n    Guide.ylabel(\"N (cm-3)\"),#hide\n    Guide.title(\"Raw Response Function\"),#hide\n    Guide.colorkey(; title = \"\"),#hide\n    Guide.xticks(#hide\n        ticks = log10.([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500]),#hide\n    ),#hide\n    Scale.x_log10(labels = x -> x in xlabels ? @sprintf(\"%2i\", exp10(x)) : \"\"),#hide\n    Scale.color_discrete_manual(\"black\"),#hide\n    Coord.cartesian(xmin = log10(10), xmax = log10(500), ymin = 0),#hide\n)#hide\n#hide\np2 = plot(#hide\n    df,#hide\n    x = :Dp,#hide\n    y = :S,#hide\n    color = :Dist,#hide\n    Geom.step,#hide\n    Guide.xlabel(\"Particle diameter (nm)\"),#hide\n    Guide.ylabel(\"dN/dlnD (cm-3)\"),#hide\n    Guide.title(\"Inverted Size Distribution\"),#hide\n    Guide.xticks(#hide\n        ticks = log10.([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500]),#hide\n    ),#hide\n    Guide.colorkey(; title = \"\"),#hide\n    Scale.x_log10(labels = x -> x in xlabels ? @sprintf(\"%2i\", exp10(x)) : \"\"),#hide\n    Scale.color_discrete_manual(colors...),#hide\n    Coord.cartesian(xmin = log10(10), xmax = log10(500), ymin = 0),#hide\n)#hide\nset_default_plot_size(20cm, 8cm)#hide\np = (hstack(p1, p2))#hide","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"The file example_data.csv is a comma delimited text files that contains diameter and a resonse vector. The function interpolateDataFrameOntoÎ´  takes the columns :Dp and :Rcn from the DataFrame df and creates a response distribution of the type SizeDistribution that matches the DMA grid Î´. Finally, ğ•Ÿâ±â¿áµ› is computed using the rinv function. ","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"The method was compared to the inverted size distribution given by the manufacturer Aerosol Instrument Manager (AIM) software, assuming no diffusion correction in either method. Figure 3 in the manuscript shows excellent correspondence between this package and the commercial software.","category":"page"},{"location":"man/inverse/#CCN-Inversion","page":"Inverse Models","title":"CCN Inversion","text":"","category":"section"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"Size resolved CCN measurements have a long history (e.g. Cruz and Pandis, 1997, Snider et al., 2006). Particles are typically dried, charge neutralized, and passed through the DMA.At the exit, the flow is split between a CPC that measures all particles and a CCN counter that measures particles that form cloud droplets at a water supersaturation set by the instrument. In this configuration the DMA voltage can either be stepped or continuously scanned. The ratio of CCN-to-CPC response function is used to determine the fraction of particles that activate at a given diameter. The diameter where 50% of the particles activate is taken to be the activation diameter. The activation of particles into cloud droplets is proportional to the volume of solute in the particle. Therefore, larger multiply charged particles activate first. This leads to a bias in the inferred D50 diameter if the activated fraction is computed from the ratio of the raw response functions (Petters et al., 2007, 2009).","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"The CCN transmission function is modeled using a cumulative Gauss integral","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"T_af = frac12left1 + mathrmerfleft(fracd-musigmaright) right","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"This function is applied to the mobility size distribution. Then the response function is computed. Empirically, activated fraction can be computed using from the ratio of size distributions and response functions. ","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"To predict the ratio of ğ•£á¶œá¶œâ¿/ğ•£á¶œâ¿ in terms of the activated fraction model Taf:","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"ğ•Ÿ^mathrmcn = (bfA^rmTbfA + lambda^rm2 bfI)^rm-1(bfA^rmT rmğ•£^mathrmcn + lambda^2 bfS^-1 rmğ•£^mathrmcn)","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"left( fracğ•£^mathrmccnğ•£^mathrmcn right)_mathrmmodel = fracmathbfAT_af * ğ•Ÿ^mathrmcnmathbfAğ•Ÿ^mathrmcn","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"This mirrors the approach in Petters et al. (2007). The model + fit can be solved using this package as follows.","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"ğ•Ÿá¶œâ¿ = (ğ€'ğ€ + Î»^2ğˆ)^(-1) * (ğ€'ğ•£á¶œâ¿  + Î»^2 * ğ’^(-1)*ğ•£á¶œâ¿)\nmodel(x,p) = (Î´.ğ€*(ğ•Ÿá¶œâ¿.N.*Taf(ğ•Ÿá¶œâ¿, p[1], p[2])))./(Î´.ğ€*ğ•Ÿá¶œâ¿.N)\nfit = curve_fit(model, Î´.Dp, ğ•£á¶œá¶œâ¿.N./ğ•£á¶œâ¿.N, [65.0, 3.0])","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"note: Note\nThe example below includes a hidden threholding step. (See complete example in the examples folder) Thresholding is performed for bins with low counts, which results in NaN and Inf in ğ•’ğ•—. This is necessary because at low concentrations a bin may have zero or very low concentration, resulting in unrealistic or NaN/InF values in the activated fraction array. Thus if counts/concentration is below the threshold, the activated fraction is forced to one for large diameters and zero for small diameters. The noise threshold may need to be adjusted for different datasets.","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"The code loads the CCN (ğ•£á¶œá¶œâ¿) and CN (ğ•£á¶œâ¿) response functions from file. The activated fraction is computed through the ratio of the distributions using one of the SizeDistribution Number Operators.","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"ğ•’ğ•— = ğ•£á¶œá¶œâ¿/ğ•£á¶œâ¿","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"And here is the complete example showing how to fit the ğ•’ğ•— response curve.","category":"page"},{"location":"man/inverse/","page":"Inverse Models","title":"Inverse Models","text":"using DataFrames, Gadfly, CSV, DifferentialMobilityAnalyzers, Printf, LsqFit, SpecialFunctions #hide\nt, p, lpm = 293.15, 940e2, 1.666e-5     \nrâ‚, râ‚‚, l = 9.37e-3,1.961e-2,0.44369    \nÎ› = DMAconfig(t,p,1lpm,4lpm,râ‚,râ‚‚,l,0.0,:+,6,:cylindrical)  \nÎ´ = setupDMA(Î›, vtoz(Î›,10000), vtoz(Î›,10), 120)\n\n# Load a simple comma delimited text file - file contains :Dp, :Rcn, :Rccn\ndf = CSV.read(\"example_data.csv\", DataFrame)\nğ•£á¶œâ¿ = (df,:Dp,:Rcn,Î´) |> interpolateDataFrameOntoÎ´        # CN response distribution\nğ•£á¶œá¶œâ¿ = (df,:Dp,:Rccn,Î´) |> interpolateDataFrameOntoÎ´;     # CCN response distribution\n#hide\nfunction threshold!(ğ•Ÿ::SizeDistribution, c::Float64, n1::Float64, n2::Float64)#hide\n    N = ğ•Ÿ.N  #hide\n    S = ğ•Ÿ.S#hide\n    S[(N .<= c) .& (ğ•Ÿ.Dp .> 150)] .= n2#hide\n    N[(N .<= c) .& (ğ•Ÿ.Dp .> 150)] .= n2#hide\n    S[(N .<= c) .& (ğ•Ÿ.Dp .< 150)] .= n1#hide\n    N[(N .<= c) .& (ğ•Ÿ.Dp .< 150)] .= n1#hide\n    ğ•Ÿ.N = N#hide\n end#hide\n #hide\nthreshold!(ğ•£á¶œâ¿, 0.1, 0.1, 0.1)#hide\nthreshold!(ğ•£á¶œá¶œâ¿, 0.1, 0.0, 0.1)#hide\n#hide\nğ•’ğ•— = ğ•£á¶œá¶œâ¿/ğ•£á¶œâ¿\nTaf(ğ•Ÿ,Î¼,Ïƒ) = @. 0.5 * (1.0 + erf((ğ•Ÿ.Dp - Î¼)./(sqrt(2.0Ïƒ))))\nğˆ, ğ’, ğ€, Î» =  Î´.ğˆ, Î´.ğ’, Î´.ğ€, 0.5\nğ•Ÿá¶œâ¿ = (ğ€'ğ€ + Î»^2ğˆ)^(-1) * (ğ€'ğ•£á¶œâ¿  + Î»^2 * ğ’^(-1)*ğ•£á¶œâ¿)\nmodel(x,p) = (ğ€ * (ğ•Ÿá¶œâ¿.N .* Taf(ğ•Ÿá¶œâ¿, p[1], p[2])))./( ğ€ * ğ•Ÿá¶œâ¿.N)\nfit = curve_fit(model, ğ•’ğ•—.Dp, ğ•’ğ•—.N, [65.0, 3.0])\nAx = fit.param\nafmodel = model(Î´.Dp, Ax)\n#hide\ndf1 = DataFrame(Dp = ğ•£á¶œâ¿.Dp, S = ğ•£á¶œâ¿.S, Dist = [\"ğ•£á¶œâ¿\" for i = 1:length(ğ•£á¶œâ¿.Dp)])#hide\ndf2 = DataFrame(Dp = ğ•£á¶œá¶œâ¿.Dp, S = ğ•£á¶œá¶œâ¿.S, Dist = [\"ğ•£á¶œá¶œâ¿\" for i = 1:length(ğ•£á¶œá¶œâ¿.Dp)])#hide\ndf = [df1; df2]#hide\n#hide\ndfr1 = DataFrame(Dp = ğ•’ğ•—.Dp, S = ğ•’ğ•—.N, Dist = [\"ğ•’ğ•— (data)\" for i = 1:length(ğ•’ğ•—.Dp)])#hide\ndfr2 = DataFrame(Dp = ğ•’ğ•—.Dp, S = afmodel, Dist = [\"ğ•’ğ•— (model)\" for i = 1:length(ğ•’ğ•—.Dp)]) #hide\ndfr = [dfr1; dfr2]#hide\n#hide\nxlabels = log10.([10, 100, 500])#hide\ncolors = [\"darkred\", \"steelblue3\", \"black\"]#hide\np1 = plot(#hide\n    dfr,#hide\n    x = :Dp,#hide\n    y = :S,#hide\n    color = :Dist,#hide\n    Geom.step,#hide\n    Guide.xlabel(\"Apparent +1 Mobility Diameter (nm)\"),#hide\n    Guide.ylabel(\"Fraction (-)\"),#hide\n    Guide.title(\"Activated Fraction\"),#hide\n    Guide.colorkey(; title = \"\"),#hide\n    Guide.xticks(#hide\n        ticks = log10.([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500]),#hide\n    ),#hide\n    Guide.yticks(ticks = collect(0:0.2:1.2)),#hide\n    Scale.x_log10(labels = x -> x in xlabels ? @sprintf(\"%2i\", exp10(x)) : \"\"),#hide\n    Scale.color_discrete_manual([\"black\", \"darkgoldenrod\"]...),#hide\n    Coord.cartesian(xmin = log10(10), xmax = log10(500), ymin = 0, ymax = 1.2),#hide\n)#hide\n#hide\np2 = plot(#hide\n    df,#hide\n    x = :Dp,#hide\n    y = :S,#hide\n    color = :Dist,#hide\n    Geom.step,#hide\n    Guide.xlabel(\"Apparent +1 Mobility Diameter (nm)\"),#hide\n    Guide.ylabel(\"dN/dlnD (cm-3)\"),#hide\n    Guide.title(\"Raw response function\"),#hide\n    Guide.xticks(#hide\n        ticks = log10.([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500]),#hide\n    ),#hide\n    Guide.colorkey(; title = \"\"),#hide\n    Scale.x_log10(labels = x -> x in xlabels ? @sprintf(\"%2i\", exp10(x)) : \"\"),#hide\n    Scale.color_discrete_manual(colors...),#hide\n    Coord.cartesian(xmin = log10(10), xmax = log10(500), ymin = 0),#hide\n)#hide\nset_default_plot_size(20cm, 8cm)#hide\np = (hstack(p2, p1))#hide","category":"page"},{"location":"man/forward/#Forward-Models","page":"Forward Models","title":"Forward Models","text":"","category":"section"},{"location":"man/forward/#Single-DMA","page":"Forward Models","title":"Single DMA","text":"","category":"section"},{"location":"man/forward/#Constant-Voltage","page":"Forward Models","title":"Constant Voltage","text":"","category":"section"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"The DMA is operated in classifier mode and set to a single voltage. The mobility classified particles are then passed to one or more detectors. Transmission can be modeled by the convolution of the particle Charging Probability, DMA Transfer Function, and Transmission Loss through the DMA. These are built into the DMA Grid. Therefore a net transmission function can be written:","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"info: Info\nThe net transmission function T describes transmission through the DMA, including the charge filter, the DMA transfer function, and the DMA transmission efficiency. T(zË¢,k,Î›,Î´) = Î´.Î©(Î›,Î´.Z,zË¢/k).*Î´.Tc(k,Î´.Dp).*Î´.Tl(Î›,Î´.Dp)where Î› is the DMA configuration, Î´ the DMA grid, zË¢ is the z-star selected by the DMA, and k is the number of charges. \t","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"The following example shows ho to use T(zË¢,k,Î›,Î´) to predict the mobility distribution exiting the DMA. In the code fragment","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"zË¢ is the z-star selected by the DMA\nğ•Ÿá¶œâ¿ is an assumed known bimodal lognormal distribution computed on the DMA size grid\nâ„• is an array of transmitted mobility distributions carrying k charges\nğ•„ is an array of transmitted apparent mobility distributions carrying k charges\nğ•Ÿâ‚œ, ğ•â‚œ are the superposition of these distributions","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"using Gadfly, NumericIO, Colors, LinearAlgebra, Printf, DataFrames, Cairo, Fontconfig # hide\nusing DifferentialMobilityAnalyzers\n\n# Create a DMA config\nqsa,qsh = 1.66e-5, 8.33e-5                       # Qsample [m3 s-1], Qsheath [m3 s-1]\nt,p = 295.15, 1e5                                # Temperature [K], Pressure [Pa]\nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               # DMA geometry [m]\nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical)  \n\n# Create a DMA grid\nzâ‚,zâ‚‚ = vtoz(Î›,10000), vtoz(Î›,10)    # bins, upper, lower mobility limit\nÎ´ = setupDMA(Î›, zâ‚, zâ‚‚, 512); \n\n# Compute the transmission through the DMA\nT(zË¢,k,Î›,Î´) = Î´.Î©(Î›,Î´.Z,zË¢/k).*Î´.Tc(k,Î´.Dp).*Î´.Tl(Î›,Î´.Dp)                  \nzË¢ = dtoz(Î›, 100*1e-9)                                                    \nğ•Ÿá¶œâ¿ = DMALognormalDistribution([[900., 40., 1.5], [500., 180., 1.4]], Î´)   \nâ„• = map(k -> T(zË¢,k,Î›,Î´)*ğ•Ÿá¶œâ¿,1:3)                                   \nğ•„ = map(k -> (ztod(Î›,1,zË¢)/ztod(Î›,k,zË¢))â‹…(T(zË¢,k,Î›,Î´)*ğ•Ÿá¶œâ¿),1:3)    \nğ•Ÿâ‚œ, ğ•â‚œ = sum(â„•), sum(ğ•„)\n# hide\nset_default_plot_size(22cm, 6cm) # hide\n# hide\nxlabels = log10.([10, 50, 100, 500]) # hide\np1 = plot( # hide\n    x = ğ•Ÿá¶œâ¿.Dp, # hide\n    y = ğ•Ÿá¶œâ¿.S, # hide\n    Geom.step, # hide\n    color = [\"ğ•Ÿá¶œâ¿\" for i in ğ•Ÿá¶œâ¿.Dp], # hide\n    Guide.xlabel(\"Particle diameter (nm)\", orientation = :horizontal), # hide\n    Guide.ylabel(\"dN/dlnD (cm-3)\", orientation = :vertical), # hide\n    Guide.xticks( # hide\n        ticks = log10.([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600]), # hide\n    ), # hide\n    Guide.colorkey(; title = \"\"),# hide\n    Scale.x_log10(labels = x -> x in xlabels ? @sprintf(\"%2i\", exp10(x)) : \"\"),# hide\n    Scale.color_discrete_manual(\"black\"),# hide\n    Coord.cartesian(xmin = log10(10), xmax = log10(600)),# hide\n    Theme(plot_padding = [0mm, 8mm, 0mm, 0mm]),# hide\n) # hide\n# hide\ndf1 = let# hide\n    xx = map(1:3) do i# hide\n        df = DataFrame(x = ğ•„[i].Dp, y = ğ•„[i].S, c = [\"ğ•„[$i]\" for j in ğ•„[i].Dp])# hide\n    end# hide\n    vcat(xx...)# hide\nend# hide\n# hide\ndf2 = DataFrame(x = ğ•â‚œ.Dp, y = ğ•â‚œ.S, c = [\"ğ•â‚œ\" for j in ğ•â‚œ.Dp])# hide\n# hide\ndf = [df2; df1]# hide\n# hide\ncolors = [\"black\", \"darkred\", \"steelblue3\", \"darkgoldenrod\"]# hide\n# hide\np2 = plot(# hide\n    df,# hide\n    x = :x,# hide\n    y = :y,# hide\n    color = :c,# hide\n    Geom.line,# hide\n    Guide.xlabel(\"Apparent +1 Mobility Diameter (nm)\", orientation = :horizontal),# hide\n    Guide.ylabel(\"\"),# hide\n    Guide.xticks(ticks = [80, 100, 120, 140]),# hide\n    Guide.colorkey(; title = \"\"),# hide\n    Scale.color_discrete_manual(colors...),# hide\n    Coord.cartesian(xmin = 70, xmax = 150),# hide\n    Theme(plot_padding = [5mm, 10mm, 0mm, 0mm]),# hide\n)# hide\n# hide\ndf1 = let# hide\n    xx = map(1:3) do i# hide\n        df = DataFrame(x = â„•[i].Dp, y = â„•[i].S, c = [\"â„•[$i]\" for j in â„•[i].Dp])# hide\n    end# hide\n    vcat(xx...)# hide\nend# hide\n# hide\ndf2 = DataFrame(x = ğ•Ÿâ‚œ.Dp, y = ğ•Ÿâ‚œ.S, c = [\"ğ•Ÿâ‚œ\" for j in ğ•Ÿâ‚œ.Dp])# hide\n# hide\ndf = [df2; df1]# hide\n# hide\np3 = plot(# hide\n    df,# hide\n    x = :x,# hide\n    y = :y,# hide\n    color = :c,# hide\n    Geom.line,# hide\n    Guide.xlabel(\"Mobility Diameter (nm)\", orientation = :horizontal),# hide\n    Guide.ylabel(\"\"),# hide\n    Guide.xticks(ticks = [100, 150, 200, 250]),# hide\n    Guide.colorkey(; title = \"\"),# hide\n    Scale.color_discrete_manual(colors...),# hide\n    Coord.cartesian(xmin = 70, xmax = 250),# hide\n    Theme(plot_padding = [0mm, 10mm, 0mm, 0mm]),# hide\n)# hide\n# hide\nhstack(p1, p2, p3)# hide","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"Figure. Left: assumed bimodal lognormal size distribution. Middle: monodisperse mobility size distribution plotted against the apparent +1 mobility diameter, defined as the apparent setpoint diameter of the DMA. Dashed line is total number concentration. Right: same as middle panel but plotted versus the mobility diameter.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"The DMA selects approximately a triangular distribution around mobility centroid z^s. The distribution is symmetric when plotted against the log of mobility, but asymmetric when plotted against the log of the apparent +1 mobility diameter because the Cunningham slip flow correction factor applied in the conversion from mobility to diameter is a strong function of particle size. The majority of selected particles are singly charged, but the contribution of multiply charged particles to the total number is not negligible. The mobility distribution has contributions from particles that are at least twice the diameter of the selected centroid diameter. The relative fractions are determined by the equilibrium charge fraction and the number of particles available at each diameter.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"info: Info\nThe map(k->f, 1:3) construct sequentially applies values from the array [1,2,3] to k and calls the function f. The output is an array of length 3. Since T(zË¢,k,Î›,Î´) produces a vector, ğ•Ÿá¶œâ¿ is a size distribution, and vector * size distribution is a size distribution, the output ofâ„• = map(k -> T(zË¢,k,Î›,Î´)*ğ•Ÿá¶œâ¿,1:3) is an array of size distributions.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"For more information see Figure 2 in the Manuscript, check out Session 2 of the Tutorial and/or Notebook S4 in the Notebooks section.","category":"page"},{"location":"man/forward/#Complete-Distribution","page":"Forward Models","title":"Complete Distribution","text":"","category":"section"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"If the DMA is stepped or scanned, the response function can be computed from the convolution Matrix ğ€ and the known true size distribution. The operation matrix * size distribution is defined in the Operators section. Thus we can conveniently write ğ•£ = ğ€ * ğ•Ÿ to compute the response function.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"using DifferentialMobilityAnalyzers #hide\nusing Gadfly #hide\nusing DataFrames #hide\nusing Colors #hide\nusing Printf #hide\nqsa,qsh = 1.66e-5, 8.33e-5               #hide\nt,p = 295.15, 1e5                       #hide\nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369         #hide\nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical)  #hide\n#hide\nzâ‚,zâ‚‚ = vtoz(Î›,10000), vtoz(Î›,10)    # #hide\nÎ´ = setupDMA(Î›, zâ‚, zâ‚‚, 60); \n#hide\nğ•Ÿ = DMALognormalDistribution([[400, 30, 1.2],[500, 110, 1.7]], Î´)\nğ•£ = Î´.ğ€ * ğ•Ÿ\n#hide\nfunction getresponse(ğ•£, ğ•Ÿ)#hide\n    df1 = DataFrame(Dp = ğ•Ÿ.Dp, S = ğ•Ÿ.S, Dist = [\"ğ•Ÿ\" for i = 1:length(ğ•Ÿ.Dp)])#hide\n    df2 = DataFrame(Dp = ğ•£.Dp, S = ğ•£.S, Dist = [\"ğ•£\" for i = 1:length(ğ•£.Dp)])#hide\n    df = [df1; df2]#hide\n#hide\n    xlabels = log10.([10, 20, 50, 100, 200, 500])#hide\n    colors = [\"black\", \"darkred\"]#hide\n#hide\n    set_default_plot_size(16cm, 9cm)#hide\n    return plot(#hide\n        df,#hide\n        x = :Dp,#hide\n        y = :S,#hide\n        color = :Dist,#hide\n        Geom.step,#hide\n        Guide.xlabel(\"Particle diameter (nm)\"),#hide\n        Guide.ylabel(\"dN/dlnD (cm-3)\"),#hide\n        Guide.xticks(#hide\n            ticks = log10.([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500]),#hide\n        ),#hide\n        Guide.colorkey(; title = \"Distribution\"),#hide\n        Scale.x_log10(labels = x -> x in xlabels ? @sprintf(\"%2i\", exp10(x)) : \"\"),#hide\n        Scale.color_discrete_manual(colors...),#hide\n        Coord.cartesian(xmin = log10(10), xmax = log10(500)),#hide\n    )#hide\nend#hide\ngetresponse(ğ•£, ğ•Ÿ) # hide","category":"page"},{"location":"man/forward/#Tandem-DMAs","page":"Forward Models","title":"Tandem DMAs","text":"","category":"section"},{"location":"man/forward/#Humidified-Tandem-DMA","page":"Forward Models","title":"Humidified Tandem DMA","text":"","category":"section"},{"location":"man/forward/#Single-Composition","page":"Forward Models","title":"Single Composition","text":"","category":"section"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"Dried, charge equilibrated particles are classified in DMA1. The flow is split to measure particle concentration with a condensation particle counter (CPC). The remaining flow is passed through a humidifier. Hygroscopic particles take up water and increase in diameter. The humidified size distribution is measured using the second DMA that is operated in scanning or stepping mode. Passage through a second bipolar charger (charge neutralizer) is optional and rarely used in TDMA experiments.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"To model transmission through the tandem DMA we need to ","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"setup two DMAs, Î´â‚ and Î´â‚‚ \nknow the input size distribution \nformulate a transmission model","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"Setting up DMAs is described in DMA Configuration. The input size distribution is assumed based on a lognormal distribution. The constructor function DMALognormalDistribution initializes a lognormal distribution along a DMA grid.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"Ax = [[1300.0, 60.0, 1.4], [2000.0, 200.0, 1.6]]\nğ•Ÿá¶œâ¿ = DMALognormalDistribution(Ax, Î´â‚)","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"The transmission model is a combination of operating DMAâ‚ at Constant Voltage and transmission of a Complete Distribution through DMAâ‚‚. ","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"# Tandem DMA equations\nTâ‚(zË¢, k) = Î´â‚.Î©(Î›â‚, Î´â‚.Z, zË¢ / k) .* Î´â‚.Tc(k, Î´â‚.Dp) .* Î´â‚.Tl(Î›â‚, Î´â‚.Dp)\ncr(zË¢, k) = ztod(Î›â‚, 1, zË¢) / ztod(Î›â‚, k, zË¢)\nDMAâ‚(ğ•Ÿ, zË¢, gf) = @_ map(cr(zË¢, _) â‹… (gfâ‚–(Î›â‚, zË¢, gf, _) â‹… (Tâ‚(zË¢, _) * ğ•Ÿ)), 1:3)\nitp(ğ•Ÿ) = interpolateSizeDistributionOntoÎ´((ğ•Ÿ, Î´â‚‚))\nDMAâ‚‚(ğ•Ÿ) = Î´â‚‚.ğ * ğ•Ÿ","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"The function T(zË¢, k, Î›, Î´) is already known. The function DMAâ‚(ğ•Ÿ, zË¢, gf) takes a distribution ğ•Ÿ and mobility zË¢ and passes it through DMA Î›â‚, Î´â‚. It returns an  array of mobility distributions and corresponds to Eq. (14) in Petters (2018), with one exception. Petters (2018) assumed that the term gfâ‚–(Î›â‚, zË¢, gf, k) is a constant. That is, the apparent growth factor is the same for multicharge particles. In fact, the  apparent growth fact, as described Gysel et al. (2009) and Shen et al. (2020), the   apparent growth factor decreases for increasing particle charge. This is described by the gfâ‚– function.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"The resulting distributions are interpolated into the same grid as DMA2 using interpolateSizeDistributionOntoÎ´.  The function DMAâ‚‚(ğ•Ÿ, Î´) takes an input size distribution ğ•Ÿ and passes it through DMAâ‚‚. No neutralizer is used. Therefore the convolution Matrix ğ is applied.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"note: Note\nThe dot product of scalar â‹… SizeDistribution shifts the size distribution in diameter space: Size Operators. Check out the Tutorial Session 1 and/or Notebook S3 in the Notebooks section for visualizations.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"Here is an abriged example how to compute the output distributions from DMA2","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"Dd = 100e-9             # Dry diameter\nzË¢ = dtoz(Î›â‚, Dd);      # Mobility of 100 nm particle\ngf = 1.6                # Growth factor\nğ•„ = @_ map(itp(_) |> DMAâ‚‚, DMAâ‚(ğ•Ÿá¶œâ¿, zË¢, gf)) # ğ•„[k] distributions\nğ•áµ— = sum(ğ•„)                                  # total response","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"ğ•„[k] correspond to the +1, +2, +3 partial mobility response functions that would be measured after DMA2. The total is obtained by the sum of these distributions Below is the complete example, which produces the response function of the tandem DMA.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"using DifferentialMobilityAnalyzers #hide\nusing Gadfly #hide\nusing NumericIO #hide\nusing Colors #hide\nusing LinearAlgebra #hide\nusing Printf #hide\nusing DataFrames #hide\nusing Underscores #hide\nimport Lazy.@>, Lazy.@>>#hide\nt, p = 295.15, 1e5                             # Temperature [K], Pressure [Pa]\nqsa, Î² = 1.66e-5, 1 / 5                        # Qsample [m3 s-1], Sample-to-sheath ratio\nrâ‚, râ‚‚, l = 9.37e-3, 1.961e-2, 0.44369         # DMA geometry [m]\nÎ›â‚ = DMAconfig(t, p, qsa, qsa / Î², râ‚, râ‚‚, l, 0.0, :-, 3, :cylindrical)  # Specify DMA1\nÎ›â‚‚ = DMAconfig(t, p, qsa, qsa / Î², râ‚, râ‚‚, l, 0.0, :-, 3, :cylindrical)  # Specify DMA2\nbins, zâ‚, zâ‚‚ = 512, dtoz(Î›â‚, 500e-9), dtoz(Î›â‚, 30e-9) # bins, upper, lower mobility limit\nÎ´â‚ = setupDMA(Î›â‚, zâ‚, zâ‚‚, bins)                  # Compute matrices\nÎ´â‚‚ = setupDMA(Î›â‚‚, zâ‚, zâ‚‚, bins)                  # Compute matrices\n\n# Upstream Size Distribution\nAx = [[1300.0, 60.0, 1.4], [5000.0, 220.0, 1.6]]\nğ•Ÿá¶œâ¿ = DMALognormalDistribution(Ax, Î´â‚)\n\n# Tandem DMA equations\nTâ‚(zË¢, k) = Î´â‚.Î©(Î›â‚, Î´â‚.Z, zË¢ / k) .* Î´â‚.Tc(k, Î´â‚.Dp) .* Î´â‚.Tl(Î›â‚, Î´â‚.Dp)\ncr(zË¢, k) = ztod(Î›â‚, 1, zË¢) / ztod(Î›â‚, k, zË¢)\nDMAâ‚(ğ•Ÿ, zË¢, gf) = @_ map(cr(zË¢, _) â‹… (gfâ‚–(Î›â‚, zË¢, gf, _) â‹… (Tâ‚(zË¢, _) * ğ•Ÿ)), 1:3)\nitp(ğ•Ÿ) = interpolateSizeDistributionOntoÎ´((ğ•Ÿ, Î´â‚‚))\nDMAâ‚‚(ğ•Ÿ) = Î´â‚‚.ğ * ğ•Ÿ\n\nDd = 100e-9             # Dry diameter\nzË¢ = dtoz(Î›â‚, Dd);      # Mobility of 100 nm particle\ngf = 1.6                # Growth factor\nğ•„ = @_ map(itp(_) |> DMAâ‚‚, DMAâ‚(ğ•Ÿá¶œâ¿, zË¢, gf)) # ğ•„[k] distributions\nğ•áµ— = sum(ğ•„)                                  # total response\n#hide\nmdf(k) = DataFrame(#hide\n    Dp = ğ•„[k].Dp./(Dd*1e9), #hide\n    S = ğ•„[k].S, #hide\n    Dist = [\"ğ•„[$k]\" for i = 1:length(ğ•„[k].Dp)]#hide\n)#hide\n#hide\ndf1 = mapreduce(mdf, vcat, 1:3)#hide\ndf2 = DataFrame(Dp = ğ•áµ—.Dp./(Dd*1e9), S = ğ•áµ—.S, Dist = [\"ğ•áµ—\" for i = 1:length(ğ•áµ—.Dp)])#hide\ndf = [df2; df1]#hide\n#hide\ncolors = [\"black\", \"darkred\", \"steelblue3\", \"darkgoldenrod\"]#hide\n#hide\np2 = plot(#hide\n    df,#hide\n    x = :Dp,#hide\n    y = :S,#hide\n    color = :Dist,#hide\n    Geom.line,#hide\n    Guide.xlabel(\"Apparent Growth Factor\", orientation = :horizontal),#hide\n    Guide.ylabel(\"dN/dlnD (cmâ»Â³)\"),#hide\n    Guide.xticks(ticks = [1.2,1.4,1.6,1.8,2.0]),#hide\n    Guide.colorkey(; title = \"\"),#hide\n    Scale.color_discrete_manual(colors...),#hide\n    Coord.cartesian(xmin = 1.2, xmax = 2),#hide\n    Theme(plot_padding = [5mm, 10mm, 0mm, 0mm]),#hide\n)#hide","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"The figure demonstrates the apparent shift toward smaller growth factors for multicharge  particles.","category":"page"},{"location":"man/forward/#Multiple-Compositions","page":"Forward Models","title":"Multiple Compositions","text":"","category":"section"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"The above example can be extended to write a TDMA model that integrates over a pdf. This function can be obtained from TDMA1Dpdf, which is part of the package.","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"function TDMA1Dpdf(ğ•Ÿáµ¢â‚™,  Î›â‚áµ¢â‚™ , Î›â‚‚áµ¢â‚™, dma2rangeáµ¢â‚™)\n    Î›â‚ , Î›â‚‚, ğ•Ÿ1 = deepcopy(Î›â‚áµ¢â‚™), deepcopy(Î›â‚‚áµ¢â‚™), deepcopy(ğ•Ÿáµ¢â‚™)\n    r = deepcopy(dma2rangeáµ¢â‚™)\n    Dd, gmin, gmax, n = r[1], r[2], r[3], r[4]\n    nDMA, Dmin, Dmax = length(ğ•Ÿ1.Dp), minimum(ğ•Ÿ1.Dp), maximum(ğ•Ÿ1.Dp)\n\n    Î´â‚ = setupDMA(Î›â‚, dtoz(Î›â‚, Dmax*1e-9), dtoz(Î›â‚, Dmin*1e-9), nDMA)\n    Î´â‚‚ = setupDMA(Î›â‚‚, dtoz(Î›â‚‚, gmax*Dd), dtoz(Î›â‚‚, gmin*Dd), n)\n    ğ•Ÿ = interpolateSizeDistributionOntoÎ´((ğ•Ÿ1, Î´â‚))\n    \n    Tâ‚(zË¢, k) = Î´â‚.Î©(Î›â‚, Î´â‚.Z, zË¢ / k) .* Î´â‚.Tc(k, Î´â‚.Dp) .* Î´â‚.Tl(Î›â‚, Î´â‚.Dp)\n    cr(zË¢, k) = ztod(Î›â‚, 1, zË¢) / ztod(Î›â‚, k, zË¢)\n    DMAâ‚(ğ•Ÿ, zË¢, gf) = sum(@_ map(cr(zË¢, _) â‹… (gfâ‚–(Î›â‚, zË¢, gf, _) â‹… (Tâ‚(zË¢, _) * ğ•Ÿ)), 1:6))\n    DMAâ‚‚(ğ•Ÿ) = Î´â‚‚.ğ * ğ•Ÿ\n    itp(ğ•Ÿ) = interpolateSizeDistributionOntoÎ´((ğ•Ÿ, Î´â‚‚))\n    TDMA(ğ•Ÿ, zË¢, gf) = @> DMAâ‚(ğ•Ÿ, zË¢, gf) itp DMAâ‚‚\n    model(ğ•Ÿ, P, Dd, gf) = sum(@_ map(P[_]*TDMA(ğ•Ÿ, dtoz(Î›â‚, Dd), gf[_]), 1:length(P)))\nend","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"Note that the basic principle is the same as the single composition above. However, DMAâ‚(ğ•Ÿ, zË¢, gf) sums directly over all charges. The function TDMA(ğ•Ÿ, zË¢, gf) returns the output from the TDMA and the function model(ğ•Ÿ, P, Dd, gf) extends this over  a pdf, where gf is a list of growth fractors and P are corresponding probabilities. ","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"Below is an example with 4 population each having a unique growth factor and fractional contribution to the total distribution. If the fractions are known, the net response function of the TDMA is readily computed. ","category":"page"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"using Distributions #hide\nusing DifferentialMobilityAnalyzers #hide\nusing Gadfly #hide\nusing Printf #hide\nt, p = 295.15, 1e5\nqsa, qsh = 1.66e-5, 8.33e-5\nrâ‚, râ‚‚, l = 9.37e-3, 1.961e-2, 0.44369\nÎ›â‚ = DMAconfig(t, p, qsa, qsh, râ‚, râ‚‚, l, 0.0, :-, 6, :cylindrical)\nÎ›â‚‚ = DMAconfig(t, p, qsa, qsh, râ‚, râ‚‚, l, 0.0, :-, 6, :cylindrical)\nbins, zâ‚, zâ‚‚ = 120, dtoz(Î›â‚, 500e-9), dtoz(Î›â‚, 30e-9) # bins, upper, lower mobility limit\nÎ´â‚ = setupDMA(Î›â‚, zâ‚, zâ‚‚, bins)                \n\nAx = [[1300.0, 60.0, 1.4], [5000.0, 220.0, 1.6]] \nğ•Ÿ = DMALognormalDistribution(Ax, Î´â‚)\n\n# scan 100 nm Dd from 0.8Dd to 3.0Dd with 100 bins\ndma2range = (100e-9, 0.8, 3.0, 120)\n\n# Get the model function\nmodel = TDMA1Dpdf(ğ•Ÿ, Î›â‚, Î›â‚‚, dma2range)\n\nP = [0.5,0.15, 0.10, 0.25]   # Probability of growth factor (4 populations)\ngf = [1.0, 1.2, 1.6, 2.1]    # Values of growth factor\nğ•˜ = model(ğ•Ÿ, P, dma2range[1], gf)\n#hide\nset_default_plot_size(14cm, 8cm)#hide\nxlabels = collect(1:0.5:3)#hide\np1 = plot(#hide\n    x = ğ•˜.Dp./100.0,#hide\n    y = ğ•˜.N,#hide\n    Geom.step,#hide\n    Guide.xlabel(\"Growth Factor (-)\"),#hide\n    Guide.ylabel(\"Number concentration (cm-3)\", orientation = :vertical),#hide\n    Guide.xticks(ticks = (collect(0.8:0.1:3))),#hide\n    Scale.x_continuous(labels = x -> x in xlabels ? @sprintf(\"%.1f\", (x)) : \"\"),#hide\n    Coord.cartesian(xmin = 0.8, xmax = 3),#hide\n    Theme(plot_padding = [2mm, 2mm, 2mm, 2mm]),#hide\n)#hide","category":"page"},{"location":"man/forward/#Volatilty-Tandem-DMA","page":"Forward Models","title":"Volatilty Tandem DMA","text":"","category":"section"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"See the Manuscript and notebook S9 in the Notebooks section for examples involving the volatility tandem DMA. ","category":"page"},{"location":"man/forward/#Dual-Tandem-DMA","page":"Forward Models","title":"Dual Tandem DMA","text":"","category":"section"},{"location":"man/forward/","page":"Forward Models","title":"Forward Models","text":"See the Manuscript and notebook S10 and S11 in the Notebooks section for examples involving the volatility tandem DMA. ","category":"page"},{"location":"man/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"The manual shows how to setup problems and includes several examples. The examples in the manual are abbreviated to focus on the key code elements. For example, commands used for plotting the results are ommitted. The complete examples are provided in the examples/ directory. ","category":"page"},{"location":"man/overview/#Examples","page":"Overview","title":"Examples","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"You can run these examples through the REPL. Download the files from GitHub. Extract the files. Start a shell and navitgate to the folder DifferentialMobilityAnalyzers.jl/examples/. Start the Julia REPS with the â€“project flag:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"julia --project","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Then run one of the examples from the REPL prompt.","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"julia> include(\"tranmsission.jl\")","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"The plots will show up in the browser.","category":"page"},{"location":"man/overview/#Further-Information","page":"Overview","title":"Further Information","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"The manual sections link to the reference for details. At each junction, the manual will provide appropriate reference to one of the Tutorial Sessions, Notebooks, and/or Figure in the Manuscript.","category":"page"},{"location":"lib/types/#Data-Types","page":"Data Types","title":"Data Types","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"Three composite data types abstract the DMA setup. The type DMAconfig includes geometry,  flow rate, and polarity.  The type DifferentialMobilityAnalyzer includes the DMA  transmission functions, convolution matrices, and a native DMA mobility grid discretization.  The type SizeDistribution includes a list of vectors to represent aerosol size distributions.  Constructor functions are available to initialize these types.","category":"page"},{"location":"lib/types/#Index","page":"Data Types","title":"Index","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"lib/types/#Types","page":"Data Types","title":"Types","text":"","category":"section"},{"location":"lib/types/#DMAconfig","page":"Data Types","title":"DMAconfig","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"DMAconfig","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.DMAconfig","page":"Data Types","title":"DifferentialMobilityAnalyzers.DMAconfig","text":"DMAconfig\n\nData type to abstract the DMA geometry and state of the fluid. \n\nt::AbstractFloat          # Temperature [K]\np::AbstractFloat          # Pressure [Pa]\nqsa::AbstractFloat        # Sample flow [m3 s-1]\nqsh::AbstractFloat        # Sheath flow [m3 s-1]\nr1::AbstractFloat         # Inner column radius [m]\nr2::AbstractFloat         # Outer column radius [m]\nl::AbstractFloat          # Column length [m]\nleff::AbstractFloat       # Effective length [m]\npolarity::Symbol          # Power supply polarity [:+] or [:-]\nm::Int8                   # Number of charges in charge correction [-]\nDMAtype::Symbol           # Designate :radial, :cylindrical\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,13.0,:-,6,:cylindrical) \n\njulia\n\nnote: Note\nWhen defining a radial DMA, râ‚,râ‚‚,l map to  râ‚,râ‚‚,b as defined in Zhang Shou-Hua Zhang,  Yoshiaki Akutsu, Lynn M. Russell, Richard C. Flagan & John H. Seinfeld (1995)  Radial Differential Mobility Analyzer, Aerosol Science and Technology,  23:3, 357-372, DOI: 10.1080/02786829508965320.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DifferentialMobilityAnalyzer","page":"Data Types","title":"DifferentialMobilityAnalyzer","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"DifferentialMobilityAnalyzer","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.DifferentialMobilityAnalyzer","page":"Data Types","title":"DifferentialMobilityAnalyzers.DifferentialMobilityAnalyzer","text":"DifferentialMobilityAnalyzer\n\nThe type DifferentialMobilityAnalyzer contains the DMA transmission functions,  a discretized mobility grid to represent the mobility distribution and precomputed convolution matrices.\n\nÎ©::Function                    # DMA transfer function\nTc::Function                   # Charge filter Function\nTl::Function                   # DMA Penetration efficiency function\nZ::Vector{<:AbstractFloat}     # Mobility array midpoints\nZe::Vector{<:AbstractFloat}    # Mobility array bin edges\nDp::Vector{<:AbstractFloat}    # Mobility diameter midpoints\nDe::Vector{<:AbstractFloat}    # Mobility diameter bin edges\nÎ”lnD::Vector{<:AbstractFloat}  # ln(de[i+1])-ln(de[i])\nğ€::AbstractMatrix              # Convolution matrix\nğ’::AbstractMatrix              # Convolution matrix for initial guess\nğ::AbstractMatrix              # Convolution matrix for no charge filter\nğˆ::AbstractMatrix               # IdentiyMatrix\n\nThe field is initialized using one of the the constructor functions:\n\nsetupDMA\nsetupSMPS\nsetupSMPSdata\n\nnote: Note\nDiameters stored in Î´ are in units of nm. Mobility in m2 s-1 V-1. The functions  Transfer Function Î©, Charging Probability Tc and  Transmission Loss Tl take diameter in units of nm\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#SizeDistribution","page":"Data Types","title":"SizeDistribution","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"SizeDistribution","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.SizeDistribution","page":"Data Types","title":"DifferentialMobilityAnalyzers.SizeDistribution","text":"SizeDistribution\n\nThe type SizeDistribution abstracts the aerosol size distribution. The parameter A is  a set of input parameters, e.g. for a lognormal function. The form contains a symbol  that traces the function or process that created the distribution.\n\nA::Any                        # Input parameters [[N1,Dg1,Ïƒg1], ...] or DMA\nDe::Vector{<:AbstractFloat}   # bin edges\nDp::Vector{<:AbstractFloat}   # bin midpoints\nÎ”lnD::Vector{<:AbstractFloat} # Î”lnD of the grid\nS::Vector{<:AbstractFloat}    # spectral density\nN::Vector{<:AbstractFloat}    # number concentration per bin\nform::Symbol                  # form of the size distribution [:lognormal, ....]\n\nSizeDistributionscan be created by hand or through one of the constructor functions:\n\nlognormal\nDMALognormalDistribution\ntriangular\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Regvars","page":"Data Types","title":"Regvars","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"Regvars","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.Regvars","page":"Data Types","title":"DifferentialMobilityAnalyzers.Regvars","text":"Regvars\n\nThe type Regvars abstracts the inversion setup, including the convolution matrix, the idenity matrix, the response function (residual vector) and the initial guess. The matrix ğ€'ğ€ is stored as precomputed matrix to avoid recomputing it when evaluating the derivatives in the l-curve search. Setting the number of BLAS threads is experimental.\n\nğ€::Matrix{Float64}     # Convolution matrix\nğˆ::Matrix{Float64}      # Identity matrix\nB::Array{Float64}      # residual vector\nXâ‚€::Array{Float64}     # initial guess\nAA::Matrix{Float64}    # precomputed ğ€'ğ€ for speed\nn::Int                 # Blas threads\n\nRegvars is initialized in the rinv function. See examples folder on how to use this  structure at the top level.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Constructor-Functions","page":"Data Types","title":"Constructor Functions","text":"","category":"section"},{"location":"lib/types/#setupDMA","page":"Data Types","title":"setupDMA","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"setupDMA","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.setupDMA","page":"Data Types","title":"DifferentialMobilityAnalyzers.setupDMA","text":"setupDMA(Î›::DMAconfig, z1::Number, z2::Number, bins::Int)\n\nConstruct the DifferentialMobilityAnalyzer type for DMA configuration DMAconfig. The size grid is constructed between mobility z1 and z2, with  bin + 1 edges and bin number of midpoints. Per convenction instantiations of this type are denoted as Î´, or Î´â‚, Î´â‚‚ ... to distinguish DMA chains. The grid must be  setup from low to high mobility, corresponding to large to small mobility diameter.\n\nDiameters stored in Î´ are in units of nm.\n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nbins,zâ‚,zâ‚‚ = 60, vtoz(Î›,10000), vtoz(Î›,10)   \n\nÎ´ = setupDMA(Î›, zâ‚, zâ‚‚, bins)\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#setupSMPS","page":"Data Types","title":"setupSMPS","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"setupSMPS","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.setupSMPS","page":"Data Types","title":"DifferentialMobilityAnalyzers.setupSMPS","text":"setupSMPS(Î›::DMAconfig, v1::Number, v2::Number, tscan::Number, tc::Number)\n\nConstruct the DifferentialMobilityAnalyzer type for DMA configuration DMAconfig. The size grid is constructed between voltage v1 and v2, tscan is  the duration of the SMPS scan in seconds, tc is the integration time per bin. The number of bins is given by tscan / tc. Per convenction instantiations of this type are denoted as Î´, or Î´â‚, Î´â‚‚ ... to distinguish DMA chains. The grid must be setup from low  voltage to high voltage. The grid is then setup in order from high to low diameter.\n\nDiameters stored in Î´ are in units of nm.\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \n\nÎ´ = setupSMPS(Î›, 10, 10000, 180, 1.5)\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#setupSMPSdata","page":"Data Types","title":"setupSMPSdata","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"setupSMPSdata","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.setupSMPSdata","page":"Data Types","title":"DifferentialMobilityAnalyzers.setupSMPSdata","text":"setupSMPSdata(Î›::DMAconfig, V::AbstractVector)\n\nConstruct the DifferentialMobilityAnalyzer type for DMA configuration DMAconfig. The size grid is constructed for a vector of voltages sorted from low to high. The voltage correspond to bin edges and might correspond to gridded data output obtained from an SMPS. The number of bins is bins = length(V)-1. \n\nDiameters stored in Î´ are in units of nm.\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \n\nV = range(10, stop = 10000, length=121)\nÎ´ = setupSMPSdata(Î›, V)\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#lognormal","page":"Data Types","title":"lognormal","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"lognormal","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.lognormal","page":"Data Types","title":"DifferentialMobilityAnalyzers.lognormal","text":"lognormal(A; d1 = 8.0, d2 = 2000.0, bins = 256)\n\nThe lognormal function instantiates a the SizeDistribution type with a multi-modal lognormal distribution. The multi-modal lognormal size distribution is given by  (e.g. Seinfeld and Pandis, 2006)\n\nfracdNdln D_p = sum_i=1^n fracN_tisqrt2pilnsigma_gi  exp left(- fracleftln D_p-ln D_pgiright^22ln sigma_gi^2right)\n\nwhere fracdNdln D_p is the spectral number density, N_ti is the total number concentration, sigma_gi is the geometric standard deviation,   D_pgi is the geometric mean diameter of the i^th mode,  nis the number of  modes.  \n\nEach mode is coded as an array of [Nt, Dg, sg]. The inputs are\n\nA is an array of arrays with modes, i.e. [[Nt1,Dg1,sg1],[Nt2,Dg2,sg2], ...]\nd1 is the lower diameter of the grid\nd2 is the upper diameter of the grid\nbins is the number of size bins.\n\nBy definition of the function sg >= 1, with sg1 corresponding to an infinitely narrow mode The function is unit agnostic. \n\nExample Usage\n\nğ•Ÿ = lognormal([[200.0, 80.0, 1.3]]; d1 = 10, d2 = 500.0, bins = 120)\nğ•Ÿ = lognormal([[200.0, 80.0, 1.3], [200.0, 150.0, 1.3]]; d1 = 10, d2 = 800.0, bins = 60)\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#DMALognormalDistribution","page":"Data Types","title":"DMALognormalDistribution","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"DMALognormalDistribution    ","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.DMALognormalDistribution","page":"Data Types","title":"DifferentialMobilityAnalyzers.DMALognormalDistribution","text":"DMALognormalDistribution(A, Î´::DifferentialMobilityAnalyzer)\n\nThe DMALognormalDistribution function instantiates a the SizeDistribution type with a multi-modal lognormal distribution. The multi-modal lognormal size distribution is given by  (e.g. Seinfeld and Pandis, 2006)\n\nfracdNdln D_p = sum_i=1^n fracN_tisqrt2pilnsigma_gi  exp left(- fracleftln D_p-ln D_pgiright^22ln sigma_gi^2right)\n\nwhere fracdNdln D_p is the spectral number density, N_ti is the total number concentration, sigma_gi is the geometric standard deviation,   D_pgi is the geometric mean diameter of the i^th mode,  nis the number of  modes.  \n\nEach mode is coded as an array of [Nt, Dg, sg]. The inputs are\n\nA is an array of arrays with modes, i.e. [[Nt1,Dg1,sg1],[Nt2,Dg2,sg2], ...]\nÎ´ is a DifferentialMobilityAnalyzer\n\nBy definition of the function sg >= 1, with sg1 corresponding to an infinitely narrow mode The function is unit agnostic. The diameter grid is that from the  DifferentialMobilityAnalyzer Î´. \n\nExample Usage\n\nt,p = 295.15, 1e5                        \nqsa,qsh = 1.66e-5, 8.3e-5                     \nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               \nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,0.0,:-,6,:cylindrical) \nbins,zâ‚,zâ‚‚ = 30, vtoz(Î›,10000), vtoz(Î›,10)   \nÎ´ = setupDMA(Î›, zâ‚, zâ‚‚, bins)\n\nğ•Ÿ = DMALognormalDistribution([[200.0, 80.0, 1.3]], Î´)\nğ•Ÿ = DMALognormalDistribution([[200.0, 80.0, 1.3], [200.0, 150.0, 1.3]], Î´)\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#triangular","page":"Data Types","title":"triangular","text":"","category":"section"},{"location":"lib/types/","page":"Data Types","title":"Data Types","text":"triangular    ","category":"page"},{"location":"lib/types/#DifferentialMobilityAnalyzers.triangular","page":"Data Types","title":"DifferentialMobilityAnalyzers.triangular","text":"triangular(Î›::DMAconfig, Î´::DifferentialMobilityAnalyzer, A)\n\nInstantiates a single mode triangular distribution in mobility space with number  concentration Nt and mode diameter Dg. This is a convenient constructor to model a single mode of the distribution output of an idealized DMA.\n\nExample Usage\n\nğ•Ÿ = triangular(Î›, Î´, [200.0, 50.0])\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Julia is just-in-time (JIT) compiled, which means that the first time you run a block of code it will be slow. Users new to Julia are strongly encouraged to start with the Docker version provided with the Tutorial. The version bundled in the Docker container comes with an optimized system image, which has a much reduced JIT lag. It also simplifies the installation. The version in the Docker container/tutorial can also be used to work with the package. ","category":"page"},{"location":"quickstart/#Documentation","page":"Quick Start","title":"Documentation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The tutorial is a guided tour of the package, including background information on the instrument and technique. The Manual section gives high-level examples on how to use the code. There is some overlap between the tutorial, the notebooks and the manual. The Library section is a browsable version of the code. It serves as reference to learn more about the definitions of operators, data types, and functions.","category":"page"},{"location":"quickstart/#Local-Installation","page":"Quick Start","title":"Local Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The package can be installed from the Julia package prompt with","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia> ]add  https://github.com/mdpetters/DifferentialMobilityAnalyzers.jl.git","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The closing square bracket switches to the package manager interface and the add command installs the package and any missing dependencies. To return to the Julia REPL hit the delete key.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"To load the package run","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia> using DifferentialMobilityAnalyzers","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Additional dependencies are needed when running the notebooks on the local install. ","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia> ] add Calculus DataFrames Distributions Glob IJulia Interpolations LambertW LinearAlgebra LsqFit NetCDF ORCA PlotlyJS Plots Printf ProgressMeter Random SpecialFunctions StatsBase Gadfly Compose","category":"page"},{"location":"man/matrix/#Creating-Convolution-Matrices","page":"Convolution Matrices","title":"Creating Convolution Matrices","text":"","category":"section"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"By convention, bold upper case letters are used to denote all matrices. In code we use Unicode UTF-8 U+1D400 to U+1D419. It's easiest to copy paste the character from  a UTF table. ","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"note: Note\nUTF-8 Captial Bold Letters: ğ€, ğ, ğ‚, ğƒ, ğ„, ğ…, ğ†, ğ‡, ğˆ, ...","category":"page"},{"location":"man/matrix/#Fredholm-Integral","page":"Convolution Matrices","title":"Fredholm Integral","text":"","category":"section"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The response in channel i (corresponding to a transmission through the DMA at a single voltage) is given by the Fredholm convolution integral ","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"R_i = int_z_a^z_b sum_k=1^m Omega(zZ_ik^s)T_c(Dz1)T_l(Dz1)fracdNdln Dfracd ln Ddzdz  i = 12n","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The integral is performed over the limits z_a and z_b, which corresponds to the upper and lower mobility limit set by the voltage range used to operate the DMA. The function fracdNdln Dfracdln Ddzdz evaluates to the number concentration of particles that lie in the interval zz + dz. Note that Dz1 is used in the charge filter and loss function since the integral is applied over the transform of the selected centroid mobility Z_ik^s. Z is the mobility vector of the grid and the subscript i denotes the response channel. The convolution integral can be discretized:  ","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"R_i = sum_j=1^n left  sum_k=1^m Omega(Z_jZ_ik^s)T_c(DZ_j1)T_l(DZ_j1)N(Z_j) right","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"N(Z_j) is the the number concentration of particles in the j^th bin, i = 1n are indices the observed instrument channel, j = 1n are indices of the physical size bins, and k = 1m are indices of charges carried by the particle. Here it is assumed that Omega(Z_jZ_ik^s) can be approximated being constant over the bin Ze_jZe_j+1, which is only true if a sufficiently large number of size bins is used. ","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The discretized version represents a set of n equations that can be written in matrix form ","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"R = mathbfAN","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"where R is the response vector, mathbfA is the convolution matrix, and N is the discretized true number concentration.","category":"page"},{"location":"man/matrix/#Computing-the-Convolution-Matrix","page":"Convolution Matrices","title":"Computing the Convolution Matrix","text":"","category":"section"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The terms comprising the convolution matrix ","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"Omega(Z_1Z_1k^s)T_c(DZ_11)T_l(DZ_11)","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"can be written as ","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"T(zË¢,k,Î›,Î´) = Î´.Î©(Î›,Î´.Z,zË¢/k).*Î´.Tc(k,Î´.Dp).*Î´.Tl(Î›,Î´.Dp)","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The generic solution to constructing the convolution matrix is to define a forward transmission model and collect the terms. The resulting matrix is n times n square matrix, where n equals to the number of bins.","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"using DifferentialMobilityAnalyzers              # hide\nqsa,qsh = 1.66e-5, 8.33e-5                       # hide\nt,p = 295.15, 1e5                                # hide\nrâ‚,râ‚‚,l = 9.37e-3,1.961e-2,0.44369               # hide\nleff = 13.0                                      # hide\nm = 6                                            # hide\nDMAtype = :cylindrical                           # hide\npolarity = :-                                    # hide\nÎ› = DMAconfig(t,p,qsa,qsh,râ‚,râ‚‚,l,leff,polarity,m,DMAtype)  # hide\nbins,zâ‚,zâ‚‚ = 60, vtoz(Î›,10000), vtoz(Î›,10)       \nÎ´ = setupDMA(Î›, zâ‚, zâ‚‚, bins)                   \nT(zË¢,k,Î›,Î´) = Î´.Î©(Î›,Î´.Z,zË¢/k).*Î´.Tc(k,Î´.Dp).*Î´.Tl(Î›,Î´.Dp)\nğ€ = (hcat(map(zË¢->Î£(k->T(zË¢,k,Î›,Î´),Î›.m),Î´.Z)...))'","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"See Notebook S2 in the Notebooks section for a step-by-step derivation. For a narrated description check out Session 2 of the Tutorial. ","category":"page"},{"location":"man/matrix/#Precomputed-Matrices","page":"Convolution Matrices","title":"Precomputed Matrices","text":"","category":"section"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The following matrices are precomputed for each DMA and stored in Î´. The structure is mutable and the matrices can be altered if needed.","category":"page"},{"location":"man/matrix/#Matrix-ğ€","page":"Convolution Matrices","title":"Matrix ğ€","text":"","category":"section"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The matrix ğ€ describes transmission through the DMA with neutralizer and transmission loss function. The matrix ğ€ is useful for modeling the measured response function of a size distribution passing through a stepping or scanning DMA.","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"Î´ = setupDMA(Î›, zâ‚, zâ‚‚, bins)                   \nT(zË¢,k,Î›,Î´) = Î´.Î©(Î›,Î´.Z,zË¢/k).*Î´.Tc(k,Î´.Dp).*Î´.Tl(Î›,Î´.Dp)\nğ€ = (hcat(map(zË¢->Î£(k->T(zË¢,k,Î›,Î´),Î›.m),Î´.Z)...))'","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The type Î´ is mutable. You can therefore override the precomputed matrix by creating your own and manually adding it to the DMA grid.","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"T(zË¢,k,Î›,Î´) = Î´.Î©(Î›,Î´.Z,zË¢/k).*Î´.Tc(k,Î´.Dp)\nmyğ€ = (hcat(map(zË¢->Î£(k->T(zË¢,k,Î›,Î´),Î›.m),Î´.Z)...))'\nÎ´.ğ€ .= myğ€","category":"page"},{"location":"man/matrix/#Matrix-ğ","page":"Convolution Matrices","title":"Matrix ğ","text":"","category":"section"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The matrix ğ describes transmission through the DMA without neutralizer and with a transmission loss function. The matrix ğ is useful for modeling the measured response function of a known mobility distribution passing through the second DMA in tandem DMA setups.","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"T(zË¢,k,Î›,Î´) = Î´.Î©(Î›,Î´.Z,zË¢/k).*Î´.Tl(Î›,Î´.Dp)\nğ = (hcat(map(zË¢->Î£(k->T(zË¢,k,Î›,Î´),Î›.m),Î´.Z)...))'","category":"page"},{"location":"man/matrix/#Matrix-ğ’","page":"Convolution Matrices","title":"Matrix ğ’","text":"","category":"section"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"Talukdar and Swihart (2003) introduced the matrix ğ’: sum the rows of ğ€ and place the results on the diagonal of ğ’. The matrix ğ’ is used to compute an initial guess to constrain the Tikhonov inverse. ","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"ğ’ = zeros(bins, bins)\nfor i = 1:bins\n\t@inbounds ğ’[i, i] = sum(ğ€[i, :])\nend","category":"page"},{"location":"man/matrix/#Matrix-ğˆ","page":"Convolution Matrices","title":"Matrix ğˆ","text":"","category":"section"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"The identity matrix is used as weights matrix when computing the Tikhoniv inverse.","category":"page"},{"location":"man/matrix/","page":"Convolution Matrices","title":"Convolution Matrices","text":"ğˆ = Matrix{Float64}(I, bins, bins)","category":"page"},{"location":"lib/inversion/#Inversion-Routines","page":"Inversion Routines","title":"Inversion Routines","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"These routines are used for size distribution inversion.","category":"page"},{"location":"lib/inversion/#Index","page":"Inversion Routines","title":"Index","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"Pages = [\"lib/inversion.md\"]","category":"page"},{"location":"lib/inversion/#Functions","page":"Inversion Routines","title":"Functions","text":"","category":"section"},{"location":"lib/inversion/#setupRegularization","page":"Inversion Routines","title":"setupRegularization","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"setupRegularization","category":"page"},{"location":"lib/inversion/#DifferentialMobilityAnalyzers.setupRegularization","page":"Inversion Routines","title":"DifferentialMobilityAnalyzers.setupRegularization","text":"setupRegularization(ğ€, ğˆ, B, Xâ‚€, n)\n\nInitialize the Regvars used to compute the Tikhonov regularization. Regvars  is a data type that stores the inversion problem setup. It also stores the precomputed  A'A matrix for performance optimization\n\nA is the convolution matrix\nI is the identity matrix\nB is the response vector\nX0 is the initial guess\nn is the number of BLAS threads \n\n\n\n\n\n","category":"function"},{"location":"lib/inversion/#Ninv","page":"Inversion Routines","title":"Ninv","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"Ninv","category":"page"},{"location":"lib/inversion/#DifferentialMobilityAnalyzers.Ninv","page":"Inversion Routines","title":"DifferentialMobilityAnalyzers.Ninv","text":"Ninv(Î»)\n\nThis function computes the regularized inverse for a specified regularization parameter Î». This requires that the problem is iniatialized throug setupRegularization.  Use the clean function to truncate negative values.\n\nExample Usage\n\n# R is the response vector\nsetupRegularization(Î´.ğ€, Î´.ğˆ, R, inv(Î´.ğ’) * R, n)  \nN = clean(Ninv(0.5))                           \n\n\n\n\n\n","category":"function"},{"location":"lib/inversion/#rinv","page":"Inversion Routines","title":"rinv","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"rinv","category":"page"},{"location":"lib/inversion/#DifferentialMobilityAnalyzers.rinv","page":"Inversion Routines","title":"DifferentialMobilityAnalyzers.rinv","text":"rinv(R::AbstractVector, Î´::DifferentialMobilityAnalyzer; Î»â‚ = 1e-2, Î»â‚‚ = 1e1, n = 1)\n\nwarning: Warning\nThis function is included to maintain backward compatibility with older code. Consider  switching to rinv2 instead.\n\nThe function rinv is a wrapper to perform the Tikhonov inversion.\n\nR the response vector to be inverted\nÎ´ the DifferentialMobilityAnalyzer from which R was produced\nÎ»â‚ and Î»â‚‚ are the bounds of the search for the optical regularization parameter\nn is the number of BLAS threads to use (currently 1 is fastest)\n\nThe function returns an inverted size distribution of type SizeDistribution\n\nExample Usage \n\n# Load Data\ndf = CSV.read(\"example_data.csv\", DataFrame)\n\n# Setup the DMA\nt, p, lpm = 293.15, 940e2, 1.666e-5      \nrâ‚, râ‚‚, l = 9.37e-3,1.961e-2,0.44369     \nÎ› = DMAconfig(t,p,1lpm,4lpm,râ‚,râ‚‚,l,0.0,:+,6,:cylindrical)  \nÎ´ = setupDMA(Î›, vtoz(Î›,10000), vtoz(Î›,10), 120)\n\n# Interpolate the data onto the DMA grid\nğ•£ = (df, :Dp, :Rcn, Î´) |> interpolateDataFrameOntoÎ´\n\n# Compute the inverse. \nğ•Ÿâ±â¿áµ› = rinv(ğ•£.N, Î´, Î»â‚ = 0.1, Î»â‚‚ = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"lib/inversion/#rinv2","page":"Inversion Routines","title":"rinv2","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"rinv2","category":"page"},{"location":"lib/inversion/#DifferentialMobilityAnalyzers.rinv2","page":"Inversion Routines","title":"DifferentialMobilityAnalyzers.rinv2","text":"rinv2(\n    R::AbstractVector,\n    Î´::DifferentialMobilityAnalyzer;\n    Î»â‚ = 1e-2,\n    Î»â‚‚ = 1e1,\n    order = 0,\n    initial = true,\n    n = 1,\n)\n\nR the response vector to be inverted\nÎ´ the DifferentialMobilityAnalyzer from which R was produced\nÎ»â‚ and Î»â‚‚ are the bounds of the search for the optical regularization parameter\norder is 0, 1, or 2 corresponding to 0th, 1st, and 2nd order Tikhonov\nuse a priori estimate from Tadlukdar and Swihart (2003) method: true/false \nn is the number of BLAS threads to use (currently 1 is fastest)\n\nThe function rinv2 is a wrapper to perform the Tikhonov inversion using  RegularizationTools. The function  supersedes rinv. It has more flexibility. For default inputs \n\n    ğ•Ÿáµ¢â‚™áµ¥ = rinv(R, Î´)\n    ğ•Ÿáµ¢â‚™áµ¥ = rinv2(R, Î´)\n\nthe two function should produce nearly identical results. The main difference is that  rinv2 used generalized cross validation instead of the L-curve method. The switch improves stability and spreed. The default setting is 0th order + initial guess, which is identical  to what is assumed in the rinv1 algorithm. Note that 0th order without initial guess  produces poor results.\n\nThe function returns an inverted size distribution of type SizeDistribution\n\nExample Usage \n\n# Load Data\ndf = CSV.read(\"example_data.csv\", DataFrame)\n\n# Setup the DMA\nt, p, lpm = 293.15, 940e2, 1.666e-5      \nrâ‚, râ‚‚, l = 9.37e-3,1.961e-2,0.44369     \nÎ› = DMAconfig(t,p,1lpm,4lpm,râ‚,râ‚‚,l,0.0,:+,6,:cylindrical)  \nÎ´ = setupDMA(Î›, vtoz(Î›,10000), vtoz(Î›,10), 120)\n\n# Interpolate the data onto the DMA grid\nğ•£ = (df, :Dp, :Rcn, Î´) |> interpolateDataFrameOntoÎ´\n\n# Compute the inverse \nğ•Ÿâ±â¿áµ› = rinv2(ğ•£.N, Î´, Î»â‚ = 0.1, Î»â‚‚ = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"lib/inversion/#L1","page":"Inversion Routines","title":"L1","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"L1","category":"page"},{"location":"lib/inversion/#DifferentialMobilityAnalyzers.L1","page":"Inversion Routines","title":"DifferentialMobilityAnalyzers.L1","text":"L1(Î»::AbstractFloat)\n\nReturns the L1 norm for regularization parameter Î»\n\nExample Usage\n\n# R is the response vector\nsetupRegularization(Î´.ğ€, Î´.ğˆ, R, inv(Î´.ğ’) * R, n)  \nL1 = L1(0.5)\n\n\n\n\n\n","category":"function"},{"location":"lib/inversion/#L2","page":"Inversion Routines","title":"L2","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"L2","category":"page"},{"location":"lib/inversion/#DifferentialMobilityAnalyzers.L2","page":"Inversion Routines","title":"DifferentialMobilityAnalyzers.L2","text":"L2(Î»::Float64)\n\nReturns the L2 norm for regularization parameter Î»\n\nExample Usage\n\n# R is the response vector\nsetupRegularization(Î´.ğ€, Î´.ğˆ, R, inv(Î´.ğ’) * R, n)  \nL2 = L2(0.5)\n\n\n\n\n\n","category":"function"},{"location":"lib/inversion/#L1L2","page":"Inversion Routines","title":"L1L2","text":"","category":"section"},{"location":"lib/inversion/","page":"Inversion Routines","title":"Inversion Routines","text":"L1L2","category":"page"},{"location":"lib/inversion/#DifferentialMobilityAnalyzers.L1L2","page":"Inversion Routines","title":"DifferentialMobilityAnalyzers.L1L2","text":"L1L2(Î»::AbstractFloat)\n\nReturns the L1 and L2 norm for regularization parameter Î»\n\nExample Usage\n\n# R is the response vector\nsetupRegularization(Î´.ğ€, Î´.ğˆ, R, inv(Î´.ğ’) * R, n)  \nL1, L2 = L1L2(0.5)\n\n\n\n\n\n","category":"function"},{"location":"#DifferentialMobilityAnalyzers.jl","page":"Home","title":"DifferentialMobilityAnalyzers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for working with data from differential mobility analyzers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DifferentialMobilityAnalyzers.jl bundles a set of abstractions to write concise forward and inverse models of experimental setups that involve  differential mobility analyzers. Abstractions include specialized data types, operators, functions, and conventions.  Conventions include rules for typesetting font and sub- and superscripting variables. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use this package in your research, please cite the relevant sources listed below. ","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Primitives to simplify working with size distribution data\nImplementation of physical equations describing DMAs\nComputational solution of the discretized Fredholm integral equation\nGeneration of custom convolution matrices \nFast size distribution inversion using Tikhonov regularization\nModeling of particle transmission through single and chained DMA setups","category":"page"},{"location":"#Citations","page":"Home","title":"Citations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was supported by the United States Department of Energy, Office of Science, Biological and Environment Research, Grant number DE-SC0018265. The tutorial was supported by the American Association of Aerosol Research. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Petters, M.D. (2018) A language to simplify computation of differential mobility analyzer response functions Aerosol Science & Technology, 52 (12), 1437-1451, https://doi.org/10.1080/02786826.2018.1530724.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Petters, M.D. (2019, April 27) Virtual Machine containing Software for \"A language to simplify computation of differential mobility analyzer response functions\" (Version 2.0), [Software], Zenodo, https://doi.org/10.5281/zenodo.2652893.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A tutorial using this package is available. The tutorial uses interactive jupyter notebooks,including audio and video clips. It features an introduction to differential mobility analyzers and the data inversion techniques. The tutorial is made available through Docker/DockerHub. This ensures low latency, no clutter from warnings, and a simple install process. ","category":"page"},{"location":"tutorial/#Docker","page":"Tutorial","title":"Docker","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Install the docker engine. Then run the tutorial  using the following command:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"docker run -it -p 8888:8888 mdpetters/data-inversion-tutorial:v2009","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will download the container (~3GB) and exectute the container. It only needs to be downloaded once. Running the command will produce an http link similar to this one:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"http://127.0.0.1:8888/?token=93b5e33a61654afded5f692325ac43f5c73eb6c58435196f","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the token is unique to each instance of the container. Follow the link and open the notebook:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Session 1 - Introduction.ipynb","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Further instructions are printed inside the notebook. The tutorial takes ~1.5 hr to complete.","category":"page"},{"location":"tutorial/#Tutorial-Files","page":"Tutorial","title":"Tutorial Files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tutorial files are hosted in a separate repository.","category":"page"},{"location":"lib/helpers/#Helper-Functions","page":"Helper Functions","title":"Helper Functions","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper Functions","title":"Helper Functions","text":"The following functions help in various task.","category":"page"},{"location":"lib/helpers/#Index","page":"Helper Functions","title":"Index","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper Functions","title":"Helper Functions","text":"Pages = [\"helpers.md\"]","category":"page"},{"location":"lib/helpers/#Functions","page":"Helper Functions","title":"Functions","text":"","category":"section"},{"location":"lib/helpers/#Î£","page":"Helper Functions","title":"Î£","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper Functions","title":"Helper Functions","text":"Î£(f, i)","category":"page"},{"location":"lib/helpers/#DifferentialMobilityAnalyzers.Î£-Tuple{Any,Any}","page":"Helper Functions","title":"DifferentialMobilityAnalyzers.Î£","text":"Î£(f, i)\n\nDefined as shorthand:\n\nÎ£(f, i) = mapreduce(f, +, 1:i)\n\nThe function evaluates f(X) for X = [1,...,i] and sums the result. If f(X) evaluates to a vector or SizeDistribution, the sum is the sum of the vectors or  SizeDistributions.\n\nExample Usage\n\nTc = getTc(Î›)\nÎ£(k -> Tc(k,100.0),2)  # evaluate the sum of Tc(1, 100.0), Tc(2, 100.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/helpers/#clean","page":"Helper Functions","title":"clean","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper Functions","title":"Helper Functions","text":"clean(x)","category":"page"},{"location":"lib/helpers/#DifferentialMobilityAnalyzers.clean-Tuple{Any}","page":"Helper Functions","title":"DifferentialMobilityAnalyzers.clean","text":"clean(x)\n\nDefined as shorthand:\n\nclean(x) = map(x -> x < 0.0 ? 0.0 : x, x)\n\nThe function removes negative numbers and set them zero. It is used to cleanup  inverted size distribution data, which may contain small negative values from inversion noise. \n\n\n\n\n\n","category":"method"},{"location":"lib/helpers/#interpolateSizeDistributionOntoÎ´","page":"Helper Functions","title":"interpolateSizeDistributionOntoÎ´","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper Functions","title":"Helper Functions","text":"interpolateSizeDistributionOntoÎ´","category":"page"},{"location":"lib/helpers/#DifferentialMobilityAnalyzers.interpolateSizeDistributionOntoÎ´","page":"Helper Functions","title":"DifferentialMobilityAnalyzers.interpolateSizeDistributionOntoÎ´","text":"interpolateSizeDistributionOntoÎ´(kw)\n\nThis function takes a size distribution and interpolates it onto a DMA grid.  kw is a tuple containing a SizeDistribution and a DMA grid.\n\nExample Usage\n\n    ğ•£ = (ğ•Ÿ, Î´) |> interpolateSizeDistributionOntoÎ´\n\nThis extracts the columns Dp and R from df and interpolates it ont grid Î´ and returns the results as a SizeDistribution. The df has to be sorted in ascending order.\n\n\n\n\n\n","category":"function"},{"location":"lib/helpers/#interpolateDataFrameOntoÎ´","page":"Helper Functions","title":"interpolateDataFrameOntoÎ´","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper Functions","title":"Helper Functions","text":"interpolateDataFrameOntoÎ´","category":"page"},{"location":"lib/helpers/#DifferentialMobilityAnalyzers.interpolateDataFrameOntoÎ´","page":"Helper Functions","title":"DifferentialMobilityAnalyzers.interpolateDataFrameOntoÎ´","text":"interpolateDataFrameOntoÎ´(kw)\n\nThis function takes some measured size distribution in a DataFrame and interpolates  it onto a DMA grid. kw is a tuple containing a DataFrame, symbols to columns to extract which contain diameter and response function, and a DMA grid.\n\nExample Usage\n\n    ğ•£ = (df, :Dp, :R, Î´) |> interpolate_df_onto_thisÎ´\n\nThis extracts the columns Dp and R from df and interpolates it ont grid Î´ and returns the results as a SizeDistribution. The df has to be sorted in ascending order.\n\n\n\n\n\n","category":"function"}]
}
