<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Convolution Matrices · DifferentialMobilityAnalyzers.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DifferentialMobilityAnalyzers.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../notebooks/">Notebooks</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../sizedistribution/">Size Distributions</a></li><li><a class="tocitem" href="../dmas/">Initializing DMAs</a></li><li class="is-active"><a class="tocitem" href>Convolution Matrices</a><ul class="internal"><li><a class="tocitem" href="#Fredholm-Integral"><span>Fredholm Integral</span></a></li><li><a class="tocitem" href="#Computing-the-Convolution-Matrix"><span>Computing the Convolution Matrix</span></a></li><li><a class="tocitem" href="#Precomputed-Matrices"><span>Precomputed Matrices</span></a></li></ul></li><li><a class="tocitem" href="../forward/">Forward Models</a></li><li><a class="tocitem" href="../inverse/">Inverse Models</a></li><li><a class="tocitem" href="../benchmarks/">Performance Benchmarks</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/physics/">Physics</a></li><li><a class="tocitem" href="../../lib/types/">Data Types</a></li><li><a class="tocitem" href="../../lib/operators/">Operators</a></li><li><a class="tocitem" href="../../lib/helpers/">Helper Functions</a></li><li><a class="tocitem" href="../../lib/inversion/">Inversion Routines</a></li><li><a class="tocitem" href="../../lib/benchmarks/">Benchmarks</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Convolution Matrices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Convolution Matrices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mdpetters/DifferentialMobilityAnalyzers.jl/blob/master/documentation/src/man/matrix.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-Convolution-Matrices"><a class="docs-heading-anchor" href="#Creating-Convolution-Matrices">Creating Convolution Matrices</a><a id="Creating-Convolution-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Convolution-Matrices" title="Permalink"></a></h1><p>By convention, bold upper case letters are used to denote all matrices. In code we use Unicode UTF-8 U+1D400 to U+1D419. It&#39;s easiest to copy paste the character from  a <a href="https://www.w3.org/TR/xml-entity-names/1D4.html">UTF table</a>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><strong>UTF-8 Captial Bold Letters:</strong> 𝐀, 𝐁, 𝐂, 𝐃, 𝐄, 𝐅, 𝐆, 𝐇, 𝐈, ...</p></div></div><h2 id="Fredholm-Integral"><a class="docs-heading-anchor" href="#Fredholm-Integral">Fredholm Integral</a><a id="Fredholm-Integral-1"></a><a class="docs-heading-anchor-permalink" href="#Fredholm-Integral" title="Permalink"></a></h2><p>The response in channel i (corresponding to a transmission through the DMA at a single voltage) is given by the Fredholm convolution integral </p><p><span>$R_i = \int_{z_a}^{z_b} \sum_{k=1}^m \Omega(z,Z_{i,k}^s)T_c(D[z,1])T_l(D[z,1])\frac{dN}{d\ln D}\frac{d \ln D}{dz}dz \;\;\;\;\;\;\ i = 1,2...,n$</span></p><p>The integral is performed over the limits <span>$z_a$</span> and <span>$z_b$</span>, which corresponds to the upper and lower mobility limit set by the voltage range used to operate the DMA. The function <span>$\frac{dN}{d\ln D}\frac{d\ln D}{dz}dz$</span> evaluates to the number concentration of particles that lie in the interval <span>$[z,z + dz]$</span>. Note that <span>$D[z,1]$</span> is used in the charge filter and loss function since the integral is applied over the transform of the selected centroid mobility <span>$Z_{i,k}^s$</span>. <span>$Z$</span> is the mobility vector of the grid and the subscript <span>$i$</span> denotes the response channel. The convolution integral can be discretized:  </p><p><span>$R_i = \sum_{j=1}^n \left [ \sum_{k=1}^m \Omega(Z_j,Z_{i,k}^s)T_c(D[Z_j,1])T_l(D[Z_j,1])N(Z_j) \right]$</span></p><p><span>$N(Z_j)$</span> is the the number concentration of particles in the <span>$j^{th}$</span> bin, <span>$i = 1...n$</span> are indices the observed instrument channel, <span>$j = 1...n$</span> are indices of the physical size bins, and <span>$k = 1...m$</span> are indices of charges carried by the particle. Here it is assumed that <span>$\Omega(Z_j,Z_{i,k}^s)$</span> can be approximated being constant over the bin <span>$[Ze_{j},Ze_{j+1}]$</span>, which is only true if a sufficiently large number of size bins is used. </p><p>The discretized version represents a set of <span>$n$</span> equations that can be written in matrix form </p><p><span>$R = \mathbf{A}N$</span></p><p>where <span>$R$</span> is the response vector, <span>$\mathbf{A}$</span> is the convolution matrix, and <span>$N$</span> is the discretized true number concentration.</p><h2 id="Computing-the-Convolution-Matrix"><a class="docs-heading-anchor" href="#Computing-the-Convolution-Matrix">Computing the Convolution Matrix</a><a id="Computing-the-Convolution-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-Convolution-Matrix" title="Permalink"></a></h2><p>The terms comprising the convolution matrix </p><p><span>$\Omega(Z_1,Z_{1,k}^s)T_c(D[Z_1,1])T_l(D[Z_1,1])$</span></p><p>can be written as </p><pre><code class="language-julia">T(zˢ,k,Λ,δ) = δ.Ω(Λ,δ.Z,zˢ/k).*δ.Tc(k,δ.Dp).*δ.Tl(Λ,δ.Dp)</code></pre><p>The generic solution to constructing the convolution matrix is to define a forward transmission model and collect the terms. The resulting matrix is <span>$n \times n$</span> square matrix, where <span>$n$</span> equals to the number of bins.</p><pre><code class="language-julia">bins,z₁,z₂ = 60, vtoz(Λ,10000), vtoz(Λ,10)
δ = setupDMA(Λ, z₁, z₂, bins)
T(zˢ,k,Λ,δ) = δ.Ω(Λ,δ.Z,zˢ/k).*δ.Tc(k,δ.Dp).*δ.Tl(Λ,δ.Dp)
𝐀 = (hcat(map(zˢ-&gt;Σ(k-&gt;T(zˢ,k,Λ,δ),Λ.m),δ.Z)...))&#39;</code></pre><pre class="documenter-example-output">60×60 Adjoint{Float64,Array{Float64,2}}:
 0.131588     0.0540361    1.19965e-16  …  4.19054e-19  0.0
 0.0605105    0.137591     0.0564765       0.0          3.64643e-51
 2.58731e-5   0.0633166    0.143694        2.96024e-33  0.0
 2.19162e-17  3.75145e-5   0.0661762       9.05185e-15  1.81298e-34
 8.031e-18    4.99485e-17  5.3083e-5       0.0          1.9204e-34
 0.0320654    5.75813e-17  9.03059e-17  …  3.57155e-49  0.0
 0.0843208    0.0325587    2.53042e-17     0.0          0.0
 0.0398241    0.0855716    0.0328725       1.22534e-69  5.05652e-15
 0.00115426   0.0404367    0.0863451       0.0          0.0
 0.0294711    0.00112585   0.0408265       0.0          2.62136e-73
 ⋮                                      ⋱               
 0.0          0.0          0.0             1.75125e-17  0.0
 0.0          0.0          0.0             0.0          3.04248e-75
 0.0          0.0          0.0             1.96499e-17  0.0
 0.0          0.0          0.0             7.95257e-12  2.70424e-22
 0.0          0.0          0.0          …  3.61098e-6   4.88025e-11
 0.0          8.74369e-19  0.0             0.00114259   6.02266e-6
 0.0          0.0          0.0             0.00980112   0.00115801
 0.0          0.0          0.0             0.0161758    0.00869253
 0.0          0.0          0.0             0.0107893    0.0139506</pre><p>See Notebook S2 in the <a href="../../notebooks/#Notebooks">Notebooks</a> section for a step-by-step derivation. For a narrated description check out Session 2 of the <a href="../../tutorial/#Tutorial">Tutorial</a>. </p><h2 id="Precomputed-Matrices"><a class="docs-heading-anchor" href="#Precomputed-Matrices">Precomputed Matrices</a><a id="Precomputed-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Precomputed-Matrices" title="Permalink"></a></h2><p>The following matrices are precomputed for each DMA and stored in δ. The structure is mutable and the matrices can be altered if needed.</p><h3 id="Matrix-𝐀"><a class="docs-heading-anchor" href="#Matrix-𝐀">Matrix 𝐀</a><a id="Matrix-𝐀-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-𝐀" title="Permalink"></a></h3><p>The matrix 𝐀 describes transmission through the DMA with neutralizer and transmission loss function. The matrix 𝐀 is useful for modeling the measured response function of a size distribution passing through a stepping or scanning DMA.</p><pre><code class="language-julia">δ = setupDMA(Λ, z₁, z₂, bins)                   
T(zˢ,k,Λ,δ) = δ.Ω(Λ,δ.Z,zˢ/k).*δ.Tc(k,δ.Dp).*δ.Tl(Λ,δ.Dp)
𝐀 = (hcat(map(zˢ-&gt;Σ(k-&gt;T(zˢ,k,Λ,δ),Λ.m),δ.Z)...))&#39;</code></pre><p>The type δ is mutable. You can therefore override the precomputed matrix by creating your own and manually adding it to the DMA grid.</p><pre><code class="language-julia">T(zˢ,k,Λ,δ) = δ.Ω(Λ,δ.Z,zˢ/k).*δ.Tc(k,δ.Dp)
my𝐀 = (hcat(map(zˢ-&gt;Σ(k-&gt;T(zˢ,k,Λ,δ),Λ.m),δ.Z)...))&#39;
δ.𝐀 .= my𝐀</code></pre><h3 id="Matrix-𝐎"><a class="docs-heading-anchor" href="#Matrix-𝐎">Matrix 𝐎</a><a id="Matrix-𝐎-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-𝐎" title="Permalink"></a></h3><p>The matrix 𝐎 describes transmission through the DMA without neutralizer and with a transmission loss function. The matrix 𝐎 is useful for modeling the measured response function of a known mobility distribution passing through the second DMA in tandem DMA setups.</p><pre><code class="language-julia">T(zˢ,k,Λ,δ) = δ.Ω(Λ,δ.Z,zˢ/k).*δ.Tl(Λ,δ.Dp)
𝐎 = (hcat(map(zˢ-&gt;Σ(k-&gt;T(zˢ,k,Λ,δ),Λ.m),δ.Z)...))&#39;</code></pre><h3 id="Matrix-𝐒"><a class="docs-heading-anchor" href="#Matrix-𝐒">Matrix 𝐒</a><a id="Matrix-𝐒-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-𝐒" title="Permalink"></a></h3><p>Talukdar and Swihart (2003) introduced the matrix 𝐒: sum the rows of 𝐀 and place the results on the diagonal of 𝐒. The matrix 𝐒 is used to compute an initial guess to constrain the Tikhonov inverse. </p><pre><code class="language-julia">𝐒 = zeros(bins, bins)
for i = 1:bins
	@inbounds 𝐒[i, i] = sum(𝐀[i, :])
end</code></pre><h3 id="Matrix-𝐈"><a class="docs-heading-anchor" href="#Matrix-𝐈">Matrix 𝐈</a><a id="Matrix-𝐈-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-𝐈" title="Permalink"></a></h3><p>The identity matrix is used as weights matrix when computing the Tikhoniv inverse.</p><pre><code class="language-julia">𝐈 = Matrix{Float64}(I, bins, bins)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dmas/">« Initializing DMAs</a><a class="docs-footer-nextpage" href="../forward/">Forward Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 August 2020 19:24">Monday 31 August 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
